<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env" />
              <option name="updatedContent" value="# Telegram Bot Configuration&#10;TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://c614d13bcb7d.ngrok-free.app&#10;&#10;# Database Configuration (для Docker)&#10;DATABASE_URL=postgresql://user:password@db:5432/giftpropaganda&#10;&#10;# Production Database (для Render)&#10;# DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;&#10;# Другие настройки&#10;DEBUG=True&#10;LOG_LEVEL=INFO&#10;REDIS_URL=redis://localhost:6379" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.env.production">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.production" />
              <option name="originalContent" value="# Production environment variables for Render&#10;# База данных - Render PostgreSQL&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda-backend.onrender.com&#10;&#10;# Продакшен настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO&#10;" />
              <option name="updatedContent" value="# Production environment variables for Render&#10;# База данных - Render PostgreSQL&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda.onrender.com&#10;&#10;# Продакшен настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.env.render">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.render" />
              <option name="updatedContent" value="# Переменные окружения для Render&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda.onrender.com&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="FROM python:3.12&#10;WORKDIR /app&#10;" />
              <option name="updatedContent" value="FROM python:3.12&#10;WORKDIR /app&#10;COPY requirements.txt .&#10;RUN pip install -r requirements.txt&#10;COPY . .&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Dockerfile.render">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile.render" />
              <option name="originalContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;COPY .env ./&#10;&#10;# Создаем пользователя для безопасности&#10;RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app&#10;USER appuser&#10;COPY .env ./&#10;&#10;# Создаем пользователя для безопасности&#10;RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app&#10;# Команда запуска&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;" />
              <option name="updatedContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска (переменные окружения будут переданы Render)&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx" />
              <option name="originalContent" value="import React, { useState, useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { fetchNews, NewsItem } from './api/news';&#10;import NewsModal from './components/NewsModal';&#10;import SearchBar from './components/SearchBar';&#10;import MediaViewer from './components/MediaViewer';&#10;import TelegramWebApp from './telegram/TelegramWebApp';&#10;&#10;// Стилизованные компоненты&#10;const AppContainer = styled.div`&#10;  min-height: 100vh;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;&#10;  padding: 0;&#10;  margin: 0;&#10;`;&#10;&#10;const Header = styled.header`&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 100;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #333);&#10;  padding: 16px;&#10;  backdrop-filter: blur(10px);&#10;`;&#10;&#10;const Title = styled.h1`&#10;  margin: 0 0 16px 0;&#10;  font-size: 24px;&#10;  font-weight: 600;&#10;  text-align: center;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;`;&#10;&#10;const CategoryTabs = styled.div`&#10;  display: flex;&#10;  gap: 8px;&#10;  overflow-x: auto;&#10;  padding: 8px 0;&#10;  margin-bottom: 16px;&#10;  &#10;  &amp;::-webkit-scrollbar {&#10;    height: 4px;&#10;  }&#10;  &#10;  &amp;::-webkit-scrollbar-track {&#10;    background: transparent;&#10;  }&#10;  &#10;  &amp;::-webkit-scrollbar-thumb {&#10;    background: var(--tg-theme-hint-color, #333);&#10;    border-radius: 2px;&#10;  }&#10;`;&#10;&#10;const CategoryTab = styled.button&lt;{ $active: boolean }&gt;`&#10;  padding: 8px 16px;&#10;  border: none;&#10;  border-radius: 20px;&#10;  background: ${props =&gt; props.$active &#10;    ? 'var(--tg-theme-button-color, #0088cc)' &#10;    : 'var(--tg-theme-secondary-bg-color, #1a1a1a)'};&#10;  color: ${props =&gt; props.$active &#10;    ? 'var(--tg-theme-button-text-color, #ffffff)' &#10;    : 'var(--tg-theme-text-color, #ffffff)'};&#10;  font-size: 14px;&#10;  font-weight: 500;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  white-space: nowrap;&#10;  min-width: fit-content;&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-1px);&#10;    box-shadow: 0 4px 12px rgba(0, 136, 204, 0.3);&#10;  }&#10;&#10;  &amp;:active {&#10;    transform: translateY(0);&#10;  }&#10;`;&#10;&#10;const NewsContainer = styled.div`&#10;  padding: 0 16px 20px 16px;&#10;  max-width: 800px;&#10;  margin: 0 auto;&#10;`;&#10;&#10;const NewsCard = styled.div&lt;{ $isNew?: boolean }&gt;`&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 12px;&#10;  padding: 0;&#10;  margin-bottom: 16px;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  position: relative;&#10;  overflow: hidden;&#10;&#10;  ${props =&gt; props.$isNew &amp;&amp; `&#10;    &amp;::before {&#10;      content: '';&#10;      position: absolute;&#10;      top: 0;&#10;      left: 0;&#10;      width: 4px;&#10;      height: 100%;&#10;      background: var(--tg-theme-button-color, #0088cc);&#10;      z-index: 1;&#10;    }&#10;  `}&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-2px);&#10;    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);&#10;    border-color: var(--tg-theme-button-color, #0088cc);&#10;  }&#10;&#10;  &amp;:active {&#10;    transform: translateY(0);&#10;  }&#10;`;&#10;&#10;const NewsCardContent = styled.div`&#10;  padding: 16px;&#10;`;&#10;&#10;const NewsHeader = styled.div`&#10;  display: flex;&#10;  align-items: flex-start;&#10;  gap: 12px;&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const NewsTextContent = styled.div`&#10;  flex: 1;&#10;  min-width: 0;&#10;`;&#10;&#10;const NewsTitle = styled.h3`&#10;  margin: 0 0 8px 0;&#10;  font-size: 16px;&#10;  font-weight: 600;&#10;  line-height: 1.4;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 2;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsPreview = styled.p`&#10;  margin: 0 0 12px 0;&#10;  font-size: 14px;&#10;  line-height: 1.5;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 3;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsMetadata = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;  gap: 12px;&#10;  padding-top: 12px;&#10;  border-top: 1px solid var(--tg-theme-hint-color, #333);&#10;`;&#10;&#10;const NewsInfo = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 12px;&#10;  font-size: 12px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  flex-wrap: wrap;&#10;`;&#10;&#10;const CategoryBadge = styled.span&lt;{ $category: string }&gt;`&#10;  padding: 4px 8px;&#10;  border-radius: 6px;&#10;  font-size: 11px;&#10;  font-weight: 500;&#10;  background: ${props =&gt; getCategoryColor(props.$category)};&#10;  color: #ffffff;&#10;  white-space: nowrap;&#10;`;&#10;&#10;const MetaItem = styled.span`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 4px;&#10;  white-space: nowrap;&#10;  &#10;  &amp;.reading-time::before {&#10;    content: '';&#10;  }&#10;  &#10;  &amp;.views::before {&#10;    content: '️';&#10;  }&#10;  &#10;  &amp;.author::before {&#10;    content: '';&#10;  }&#10;`;&#10;&#10;const MediaContainer = styled.div`&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const StyledMediaViewer = styled(MediaViewer)`&#10;  border-radius: 0;&#10;  &#10;  &amp;:first-child {&#10;    border-top-left-radius: 12px;&#10;    border-top-right-radius: 12px;&#10;  }&#10;`;&#10;&#10;const LoadingSpinner = styled.div`&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  padding: 40px;&#10;  &#10;  &amp;::after {&#10;    content: '';&#10;    width: 32px;&#10;    height: 32px;&#10;    border: 3px solid var(--tg-theme-hint-color, #333);&#10;    border-top: 3px solid var(--tg-theme-button-color, #0088cc);&#10;    border-radius: 50%;&#10;    animation: spin 1s linear infinite;&#10;  }&#10;  &#10;  @keyframes spin {&#10;    0% { transform: rotate(0deg); }&#10;    100% { transform: rotate(360deg); }&#10;  }&#10;`;&#10;&#10;const ErrorMessage = styled.div`&#10;  text-align: center;&#10;  padding: 40px 20px;&#10;  color: var(--tg-theme-destructive-text-color, #ff4444);&#10;  font-size: 16px;&#10;`;&#10;&#10;const EmptyState = styled.div`&#10;  text-align: center;&#10;  padding: 60px 20px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  &#10;  h3 {&#10;    margin: 0 0 8px 0;&#10;    font-size: 18px;&#10;    color: var(--tg-theme-text-color, #ffffff);&#10;  }&#10;  &#10;  p {&#10;    margin: 0;&#10;    font-size: 14px;&#10;  }&#10;`;&#10;&#10;// Функция для получения цвета категории&#10;function getCategoryColor(category: string): string {&#10;  const colors: Record&lt;string, string&gt; = {&#10;    'gifts': '#ff6b6b',&#10;    'crypto': '#4ecdc4',&#10;    'tech': '#45b7d1',&#10;    'community': '#96ceb4',&#10;    'gaming': '#feca57',&#10;    'news': '#ff9ff3',&#10;    'default': '#6c5ce7'&#10;  };&#10;  return colors[category] || colors.default;&#10;}&#10;&#10;// Функция для форматирования времени&#10;function formatTimeAgo(dateString: string): string {&#10;  const now = new Date();&#10;  const date = new Date(dateString);&#10;  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);&#10;&#10;  if (diffInSeconds &lt; 60) return 'только что';&#10;  if (diffInSeconds &lt; 3600) return `${Math.floor(diffInSeconds / 60)} мин назад`;&#10;  if (diffInSeconds &lt; 86400) return `${Math.floor(diffInSeconds / 3600)} ч назад`;&#10;  return `${Math.floor(diffInSeconds / 86400)} дн назад`;&#10;}&#10;&#10;// Основной компонент&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsItem[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [selectedCategory, setSelectedCategory] = useState('all');&#10;  const [searchQuery, setSearchQuery] = useState('');&#10;  const [selectedNews, setSelectedNews] = useState&lt;NewsItem | null&gt;(null);&#10;&#10;  const categories = [&#10;    { id: 'all', name: 'Все', icon: '' },&#10;    { id: 'gifts', name: 'Подарки', icon: '' },&#10;    { id: 'crypto', name: 'Крипто', icon: '₿' },&#10;    { id: 'tech', name: 'Технологии', icon: '' },&#10;    { id: 'community', name: 'Сообщество', icon: '' },&#10;    { id: 'nft', name: 'NFT', icon: '️' }&#10;  ];&#10;&#10;  useEffect(() =&gt; {&#10;    TelegramWebApp.init();&#10;  }, []);&#10;&#10;  const getNews = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setError(null);&#10;      const response = await fetchNews(selectedCategory === 'all' ? undefined : selectedCategory);&#10;      setNews(response.data);&#10;    } catch (err) {&#10;      console.error('Ошибка при загрузке новостей:', err);&#10;      setError('Не удалось загрузить новости. Попробуйте еще раз.');&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    getNews();&#10;  }, [selectedCategory]);&#10;&#10;  const handleNewsClick = (newsItem: NewsItem) =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    setSelectedNews(newsItem);&#10;  };&#10;&#10;  const handleCategoryChange = (categoryId: string) =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    setSelectedCategory(categoryId);&#10;  };&#10;&#10;  const filteredNews = news.filter(item =&gt;&#10;    item.title.toLowerCase().includes(searchQuery.toLowerCase()) ||&#10;    item.content.toLowerCase().includes(searchQuery.toLowerCase())&#10;  );&#10;&#10;  const isNewNews = (dateString: string): boolean =&gt; {&#10;    const now = new Date();&#10;    const date = new Date(dateString);&#10;    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);&#10;    return diffInHours &lt; 24;&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;AppContainer&gt;&#10;        &lt;Header&gt;&#10;          &lt;Title&gt;Новости от Telegram&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/AppContainer&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;AppContainer&gt;&#10;        &lt;Header&gt;&#10;          &lt;Title&gt;Новости от Telegram&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;        &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;&#10;      &lt;/AppContainer&gt;&#10;    );&#10;  }&#10;&#10;  const renderNewsCard = (item: NewsItem) =&gt; {&#10;    const hasMedia = item.image_url || item.video_url;&#10;&#10;    return (&#10;      &lt;NewsCard&#10;        key={item.id}&#10;        $isNew={isNewNews(item.publish_date)}&#10;        onClick={() =&gt; handleNewsClick(item)}&#10;      &gt;&#10;        {hasMedia &amp;&amp; (&#10;          &lt;MediaContainer&gt;&#10;            &lt;StyledMediaViewer&#10;              imageUrl={item.image_url}&#10;              videoUrl={item.video_url}&#10;              title={item.title}&#10;            /&gt;&#10;          &lt;/MediaContainer&gt;&#10;        )}&#10;&#10;        &lt;NewsCardContent&gt;&#10;          &lt;NewsHeader&gt;&#10;            &lt;NewsTextContent&gt;&#10;              &lt;NewsTitle&gt;{item.title}&lt;/NewsTitle&gt;&#10;              &lt;NewsPreview&gt;{item.content}&lt;/NewsPreview&gt;&#10;            &lt;/NewsTextContent&gt;&#10;          &lt;/NewsHeader&gt;&#10;&#10;          &lt;NewsMetadata&gt;&#10;            &lt;NewsInfo&gt;&#10;              &lt;CategoryBadge $category={item.category}&gt;&#10;                {categories.find(cat =&gt; cat.id === item.category)?.icon} {' '}&#10;                {categories.find(cat =&gt; cat.id === item.category)?.name || item.category}&#10;              &lt;/CategoryBadge&gt;&#10;&#10;              &lt;span&gt;{formatTimeAgo(item.publish_date)}&lt;/span&gt;&#10;&#10;              {item.reading_time &amp;&amp; (&#10;                &lt;MetaItem className=&quot;reading-time&quot;&gt;{item.reading_time} мин&lt;/MetaItem&gt;&#10;              )}&#10;&#10;              {item.views_count !== undefined &amp;&amp; (&#10;                &lt;MetaItem className=&quot;views&quot;&gt;{item.views_count}&lt;/MetaItem&gt;&#10;              )}&#10;&#10;              {item.author &amp;&amp; (&#10;                &lt;MetaItem className=&quot;author&quot;&gt;{item.author}&lt;/MetaItem&gt;&#10;              )}&#10;            &lt;/NewsInfo&gt;&#10;          &lt;/NewsMetadata&gt;&#10;        &lt;/NewsCardContent&gt;&#10;      &lt;/NewsCard&gt;&#10;    );&#10;  };&#10;&#10;  return (&#10;    &lt;AppContainer&gt;&#10;      &lt;Header&gt;&#10;        &lt;Title&gt; Gift Propaganda News&lt;/Title&gt;&#10;&#10;        &lt;SearchBar&#10;          value={searchQuery}&#10;          onChange={setSearchQuery}&#10;          placeholder=&quot;Поиск новостей...&quot;&#10;        /&gt;&#10;&#10;        &lt;CategoryTabs&gt;&#10;          {categories.map(category =&gt; (&#10;            &lt;CategoryTab&#10;              key={category.id}&#10;              $active={selectedCategory === category.id}&#10;              onClick={() =&gt; handleCategoryChange(category.id)}&#10;            &gt;&#10;              &lt;span&gt;{category.icon}&lt;/span&gt;&#10;              &lt;span&gt;{category.name}&lt;/span&gt;&#10;            &lt;/CategoryTab&gt;&#10;          ))}&#10;        &lt;/CategoryTabs&gt;&#10;      &lt;/Header&gt;&#10;&#10;      &lt;NewsContainer&gt;&#10;        {filteredNews.length === 0 ? (&#10;          &lt;EmptyState&gt;&#10;            &lt;h3&gt; Новостей не найдено&lt;/h3&gt;&#10;            &lt;p&gt;Попробуйте изменить категорию или поисковый запрос&lt;/p&gt;&#10;          &lt;/EmptyState&gt;&#10;        ) : (&#10;          filteredNews.map(item =&gt; renderNewsCard(item))&#10;        )}&#10;      &lt;/NewsContainer&gt;&#10;&#10;      {selectedNews &amp;&amp; (&#10;        &lt;NewsModal&#10;          news={selectedNews}&#10;          isOpen={!!selectedNews}&#10;          onClose={() =&gt; setSelectedNews(null)}&#10;        /&gt;&#10;      )}&#10;    &lt;/AppContainer&gt;&#10;  );&#10;};&#10;&#10;export default App;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { fetchNews, NewsItem } from './api/news';&#10;import NewsModal from './components/NewsModal';&#10;import SearchBar from './components/SearchBar';&#10;import MediaViewer from './components/MediaViewer';&#10;import TelegramWebApp from './telegram/TelegramWebApp';&#10;&#10;// Стилизованные компоненты&#10;const AppContainer = styled.div`&#10;  min-height: 100vh;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;&#10;  padding: 0;&#10;  margin: 0;&#10;`;&#10;&#10;const Header = styled.header`&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 100;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #333);&#10;  padding: 12px 16px;&#10;  backdrop-filter: blur(10px);&#10;`;&#10;&#10;const HeaderTop = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const Title = styled.h1`&#10;  margin: 0;&#10;  font-size: 20px;&#10;  font-weight: 700;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 8px;&#10;`;&#10;&#10;const StatsBar = styled.div`&#10;  display: flex;&#10;  gap: 16px;&#10;  margin-bottom: 12px;&#10;  font-size: 14px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;`;&#10;&#10;const StatItem = styled.span&lt;{ $color?: string }&gt;`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 4px;&#10;  font-weight: 500;&#10;  color: ${props =&gt; props.$color || 'var(--tg-theme-hint-color, #999)'};&#10;`;&#10;&#10;const CategoryTabs = styled.div`&#10;  display: flex;&#10;  gap: 8px;&#10;  overflow-x: auto;&#10;  padding: 8px 0 4px 0;&#10;  margin-bottom: 8px;&#10;  &#10;  &amp;::-webkit-scrollbar {&#10;    height: 3px;&#10;  }&#10;  &#10;  &amp;::-webkit-scrollbar-track {&#10;    background: transparent;&#10;  }&#10;  &#10;  &amp;::-webkit-scrollbar-thumb {&#10;    background: var(--tg-theme-hint-color, #333);&#10;    border-radius: 2px;&#10;  }&#10;`;&#10;&#10;const CategoryTab = styled.button&lt;{ $active: boolean }&gt;`&#10;  padding: 6px 12px;&#10;  border: none;&#10;  border-radius: 16px;&#10;  background: ${props =&gt; props.$active &#10;    ? 'var(--tg-theme-button-color, #0088cc)' &#10;    : 'var(--tg-theme-secondary-bg-color, #1a1a1a)'};&#10;  color: ${props =&gt; props.$active &#10;    ? 'var(--tg-theme-button-text-color, #ffffff)' &#10;    : 'var(--tg-theme-text-color, #ffffff)'};&#10;  font-size: 13px;&#10;  font-weight: 500;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  white-space: nowrap;&#10;  min-width: fit-content;&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 4px;&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-1px);&#10;    box-shadow: 0 4px 12px rgba(0, 136, 204, 0.3);&#10;  }&#10;&#10;  &amp;:active {&#10;    transform: translateY(0);&#10;  }&#10;`;&#10;&#10;const NewsContainer = styled.div`&#10;  padding: 0 16px 20px 16px;&#10;  max-width: 800px;&#10;  margin: 0 auto;&#10;`;&#10;&#10;const NewsCard = styled.div&lt;{ $isNew?: boolean }&gt;`&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 8px;&#10;  margin-bottom: 12px;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  position: relative;&#10;  overflow: hidden;&#10;&#10;  ${props =&gt; props.$isNew &amp;&amp; `&#10;    &amp;::before {&#10;      content: '';&#10;      position: absolute;&#10;      top: 0;&#10;      left: 0;&#10;      width: 3px;&#10;      height: 100%;&#10;      background: var(--tg-theme-button-color, #0088cc);&#10;      z-index: 1;&#10;    }&#10;  `}&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-1px);&#10;    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);&#10;    border-color: var(--tg-theme-button-color, #0088cc);&#10;  }&#10;&#10;  &amp;:active {&#10;    transform: translateY(0);&#10;  }&#10;`;&#10;&#10;const NewsCardContent = styled.div`&#10;  padding: 14px 16px;&#10;`;&#10;&#10;const NewsHeader = styled.div`&#10;  display: flex;&#10;  align-items: flex-start;&#10;  gap: 12px;&#10;  margin-bottom: 10px;&#10;`;&#10;&#10;const NewsImagePreview = styled.div`&#10;  width: 60px;&#10;  height: 60px;&#10;  border-radius: 6px;&#10;  overflow: hidden;&#10;  flex-shrink: 0;&#10;  background: var(--tg-theme-hint-color, #333);&#10;  &#10;  img {&#10;    width: 100%;&#10;    height: 100%;&#10;    object-fit: cover;&#10;  }&#10;`;&#10;&#10;const NewsTextContent = styled.div`&#10;  flex: 1;&#10;  min-width: 0;&#10;`;&#10;&#10;const NewsTitle = styled.h3`&#10;  margin: 0 0 6px 0;&#10;  font-size: 15px;&#10;  font-weight: 600;&#10;  line-height: 1.3;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 2;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsPreview = styled.p`&#10;  margin: 0 0 8px 0;&#10;  font-size: 13px;&#10;  line-height: 1.4;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 2;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsMetadata = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;  gap: 8px;&#10;  margin-top: 8px;&#10;`;&#10;&#10;const NewsInfo = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 8px;&#10;  font-size: 11px;&#10;  color: var(--tg-theme-hint-color, #888);&#10;  flex-wrap: wrap;&#10;`;&#10;&#10;const CategoryBadge = styled.span&lt;{ $category: string }&gt;`&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  font-size: 10px;&#10;  font-weight: 500;&#10;  background: ${props =&gt; getCategoryColor(props.$category)};&#10;  color: #ffffff;&#10;  white-space: nowrap;&#10;`;&#10;&#10;const MetaItem = styled.span`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 3px;&#10;  white-space: nowrap;&#10;  font-size: 11px;&#10;`;&#10;&#10;const InteractionBar = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 12px;&#10;  font-size: 11px;&#10;  color: var(--tg-theme-hint-color, #888);&#10;`;&#10;&#10;const InteractionButton = styled.button`&#10;  background: none;&#10;  border: none;&#10;  color: var(--tg-theme-hint-color, #888);&#10;  font-size: 11px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 3px;&#10;  padding: 0;&#10;  transition: color 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    color: var(--tg-theme-text-color, #ffffff);&#10;  }&#10;`;&#10;&#10;const MediaContainer = styled.div`&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const StyledMediaViewer = styled(MediaViewer)`&#10;  border-radius: 0;&#10;  &#10;  &amp;:first-child {&#10;    border-top-left-radius: 12px;&#10;    border-top-right-radius: 12px;&#10;  }&#10;`;&#10;&#10;const LoadingSpinner = styled.div`&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  padding: 40px;&#10;  &#10;  &amp;::after {&#10;    content: '';&#10;    width: 32px;&#10;    height: 32px;&#10;    border: 3px solid var(--tg-theme-hint-color, #333);&#10;    border-top: 3px solid var(--tg-theme-button-color, #0088cc);&#10;    border-radius: 50%;&#10;    animation: spin 1s linear infinite;&#10;  }&#10;  &#10;  @keyframes spin {&#10;    0% { transform: rotate(0deg); }&#10;    100% { transform: rotate(360deg); }&#10;  }&#10;`;&#10;&#10;const ErrorMessage = styled.div`&#10;  text-align: center;&#10;  padding: 40px 20px;&#10;  color: var(--tg-theme-destructive-text-color, #ff4444);&#10;  font-size: 16px;&#10;`;&#10;&#10;const EmptyState = styled.div`&#10;  text-align: center;&#10;  padding: 60px 20px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  &#10;  h3 {&#10;    margin: 0 0 8px 0;&#10;    font-size: 18px;&#10;    color: var(--tg-theme-text-color, #ffffff);&#10;  }&#10;  &#10;  p {&#10;    margin: 0;&#10;    font-size: 14px;&#10;  }&#10;`;&#10;&#10;// Функция для получения цвета категории&#10;function getCategoryColor(category: string): string {&#10;  const colors: Record&lt;string, string&gt; = {&#10;    'gifts': '#ff6b6b',&#10;    'crypto': '#4ecdc4',&#10;    'tech': '#45b7d1',&#10;    'community': '#96ceb4',&#10;    'gaming': '#feca57',&#10;    'news': '#ff9ff3',&#10;    'default': '#6c5ce7'&#10;  };&#10;  return colors[category] || colors.default;&#10;}&#10;&#10;// Функция для форматирования времени&#10;function formatTimeAgo(dateString: string): string {&#10;  const now = new Date();&#10;  const date = new Date(dateString);&#10;  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);&#10;&#10;  if (diffInSeconds &lt; 60) return 'только что';&#10;  if (diffInSeconds &lt; 3600) return `${Math.floor(diffInSeconds / 60)} мин назад`;&#10;  if (diffInSeconds &lt; 86400) return `${Math.floor(diffInSeconds / 3600)} ч назад`;&#10;  return `${Math.floor(diffInSeconds / 86400)} дн назад`;&#10;}&#10;&#10;// Основной компонент&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsItem[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [selectedCategory, setSelectedCategory] = useState('all');&#10;  const [searchQuery, setSearchQuery] = useState('');&#10;  const [selectedNews, setSelectedNews] = useState&lt;NewsItem | null&gt;(null);&#10;&#10;  const categories = [&#10;    { id: 'all', name: 'Все потоки', icon: '' },&#10;    { id: 'gifts', name: 'Подарки', icon: '' },&#10;    { id: 'crypto', name: 'Крипто', icon: '₿' },&#10;    { id: 'tech', name: 'Технологии', icon: '' },&#10;    { id: 'community', name: 'Сообщество', icon: '' },&#10;    { id: 'nft', name: 'NFT', icon: '️' }&#10;  ];&#10;&#10;  useEffect(() =&gt; {&#10;    TelegramWebApp.init();&#10;  }, []);&#10;&#10;  const getNews = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setError(null);&#10;      const response = await fetchNews(selectedCategory === 'all' ? undefined : selectedCategory);&#10;      setNews(response.data);&#10;    } catch (err) {&#10;      console.error('Ошибка при загрузке новостей:', err);&#10;      setError('Не удалось загрузить новости. Попробуйте еще раз.');&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    getNews();&#10;  }, [selectedCategory]);&#10;&#10;  const handleNewsClick = (newsItem: NewsItem) =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    setSelectedNews(newsItem);&#10;  };&#10;&#10;  const handleCategoryChange = (categoryId: string) =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    setSelectedCategory(categoryId);&#10;  };&#10;&#10;  const filteredNews = news.filter(item =&gt;&#10;    item.title.toLowerCase().includes(searchQuery.toLowerCase()) ||&#10;    item.content.toLowerCase().includes(searchQuery.toLowerCase())&#10;  );&#10;&#10;  const isNewNews = (dateString: string): boolean =&gt; {&#10;    const now = new Date();&#10;    const date = new Date(dateString);&#10;    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);&#10;    return diffInHours &lt; 24;&#10;  };&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;AppContainer&gt;&#10;        &lt;Header&gt;&#10;          &lt;Title&gt;Новости от Telegram&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;        &lt;LoadingSpinner /&gt;&#10;      &lt;/AppContainer&gt;&#10;    );&#10;  }&#10;&#10;  if (error) {&#10;    return (&#10;      &lt;AppContainer&gt;&#10;        &lt;Header&gt;&#10;          &lt;Title&gt;Новости от Telegram&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;        &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;&#10;      &lt;/AppContainer&gt;&#10;    );&#10;  }&#10;&#10;  const renderNewsCard = (item: NewsItem) =&gt; {&#10;    const hasMedia = item.image_url || item.video_url;&#10;&#10;    return (&#10;      &lt;NewsCard&#10;        key={item.id}&#10;        $isNew={isNewNews(item.publish_date)}&#10;        onClick={() =&gt; handleNewsClick(item)}&#10;      &gt;&#10;        &lt;NewsCardContent&gt;&#10;          &lt;NewsHeader&gt;&#10;            {hasMedia &amp;&amp; (&#10;              &lt;NewsImagePreview&gt;&#10;                &lt;img &#10;                  src={item.image_url || '/placeholder.png'} &#10;                  alt={item.title}&#10;                  onError={(e) =&gt; {&#10;                    e.currentTarget.style.display = 'none';&#10;                  }}&#10;                /&gt;&#10;              &lt;/NewsImagePreview&gt;&#10;            )}&#10;            &lt;NewsTextContent&gt;&#10;              &lt;NewsTitle&gt;{item.title}&lt;/NewsTitle&gt;&#10;              &lt;NewsPreview&gt;{item.content}&lt;/NewsPreview&gt;&#10;              &#10;              &lt;NewsMetadata&gt;&#10;                &lt;NewsInfo&gt;&#10;                  &lt;CategoryBadge $category={item.category}&gt;&#10;                    {categories.find(cat =&gt; cat.id === item.category)?.name || item.category}&#10;                  &lt;/CategoryBadge&gt;&#10;&#10;                  &lt;MetaItem&gt;&#10;                    {formatTimeAgo(item.publish_date)}&#10;                  &lt;/MetaItem&gt;&#10;&#10;                  {item.reading_time &amp;&amp; (&#10;                    &lt;MetaItem&gt; {item.reading_time} мин&lt;/MetaItem&gt;&#10;                  )}&#10;&#10;                  {item.views_count !== undefined &amp;&amp; (&#10;                    &lt;MetaItem&gt;️ {item.views_count}&lt;/MetaItem&gt;&#10;                  )}&#10;                &lt;/NewsInfo&gt;&#10;&#10;                &lt;InteractionBar&gt;&#10;                  &lt;InteractionButton&gt;&#10;                     +2&#10;                  &lt;/InteractionButton&gt;&#10;                  &lt;InteractionButton&gt;&#10;                     0&#10;                  &lt;/InteractionButton&gt;&#10;                  &lt;InteractionButton&gt;&#10;                     3&#10;                  &lt;/InteractionButton&gt;&#10;                &lt;/InteractionBar&gt;&#10;              &lt;/NewsMetadata&gt;&#10;            &lt;/NewsTextContent&gt;&#10;          &lt;/NewsHeader&gt;&#10;        &lt;/NewsCardContent&gt;&#10;      &lt;/NewsCard&gt;&#10;    );&#10;  };&#10;&#10;  return (&#10;    &lt;AppContainer&gt;&#10;      &lt;Header&gt;&#10;        &lt;HeaderTop&gt;&#10;          &lt;Title&gt;&#10;             Gift Propaganda&#10;          &lt;/Title&gt;&#10;        &lt;/HeaderTop&gt;&#10;&#10;        &lt;StatsBar&gt;&#10;          &lt;StatItem $color=&quot;#4ade80&quot;&gt;СТАТЬИ +78&lt;/StatItem&gt;&#10;          &lt;StatItem $color=&quot;#60a5fa&quot;&gt;ПОСТЫ +20&lt;/StatItem&gt;&#10;          &lt;StatItem $color=&quot;#a78bfa&quot;&gt;НОВОСТИ +54&lt;/StatItem&gt;&#10;        &lt;/StatsBar&gt;&#10;&#10;        &lt;SearchBar&#10;          value={searchQuery}&#10;          onChange={setSearchQuery}&#10;          placeholder=&quot;Поиск новостей...&quot;&#10;        /&gt;&#10;&#10;        &lt;CategoryTabs&gt;&#10;          {categories.map(category =&gt; (&#10;            &lt;CategoryTab&#10;              key={category.id}&#10;              $active={selectedCategory === category.id}&#10;              onClick={() =&gt; handleCategoryChange(category.id)}&#10;            &gt;&#10;              {category.icon &amp;&amp; &lt;span&gt;{category.icon}&lt;/span&gt;}&#10;              &lt;span&gt;{category.name}&lt;/span&gt;&#10;            &lt;/CategoryTab&gt;&#10;          ))}&#10;        &lt;/CategoryTabs&gt;&#10;      &lt;/Header&gt;&#10;&#10;      &lt;NewsContainer&gt;&#10;        {filteredNews.length === 0 ? (&#10;          &lt;EmptyState&gt;&#10;            &lt;h3&gt; Новостей не найдено&lt;/h3&gt;&#10;            &lt;p&gt;Попробуйте изменить категорию или поисковый запрос&lt;/p&gt;&#10;          &lt;/EmptyState&gt;&#10;        ) : (&#10;          filteredNews.map(item =&gt; renderNewsCard(item))&#10;        )}&#10;      &lt;/NewsContainer&gt;&#10;&#10;      {selectedNews &amp;&amp; (&#10;        &lt;NewsModal&#10;          news={selectedNews}&#10;          isOpen={!!selectedNews}&#10;          onClose={() =&gt; setSelectedNews(null)}&#10;        /&gt;&#10;      )}&#10;    &lt;/AppContainer&gt;&#10;  );&#10;};&#10;&#10;export default App;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;// Определяем API URL в зависимости от окружения&#10;const API_URL = process.env.NODE_ENV === 'production'&#10;  ? 'https://giftpropaganda.onrender.com/api/news/'&#10;  : 'http://localhost:8000/api/news/';&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  source?: {&#10;    name: string;&#10;    type: string;&#10;  };&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (category?: string): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const url = category ? `${API_URL}?category=${category}` : API_URL;&#10;&#10;    const response = await axios.get&lt;NewsResponse&gt;(url, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000 // 10 секунд таймаут&#10;    });&#10;&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;&#10;    // Возвращаем более детальную информацию об ошибке&#10;    let errorMessage = 'Ошибка загрузки новостей';&#10;    if (error.response) {&#10;      errorMessage = `Ошибка сервера: ${error.response.status}`;&#10;    } else if (error.request) {&#10;      errorMessage = 'Нет ответа от сервера';&#10;    }&#10;&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: errorMessage&#10;    };&#10;  }&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;// Определяем API URL в зависимости от окружения&#10;const API_URL = process.env.NODE_ENV === 'production'&#10;  ? 'https://giftpropaganda.onrender.com/api/news/'&#10;  : 'http://localhost:8000/api/news/';&#10;&#10;export interface MediaItem {&#10;  type: 'photo' | 'video';&#10;  url: string;&#10;  thumbnail?: string;&#10;  width?: number;&#10;  height?: number;&#10;  duration?: number; // Для видео&#10;  size?: number; // Размер файла&#10;}&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  image_url?: string; // Основное изображение&#10;  video_url?: string; // Основное видео&#10;  reading_time?: number;&#10;  views_count?: number;&#10;  author?: string;&#10;  subtitle?: string;&#10;  media?: MediaItem; // Дополнительное медиа&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;  total?: number;&#10;  page?: number;&#10;  limit?: number;&#10;}&#10;&#10;export const fetchNews = async (category?: string): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const url = category ? `${API_URL}?category=${category}` : API_URL;&#10;&#10;    const response = await axios.get&lt;NewsResponse&gt;(url, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 15000 // Увеличиваем таймаут до 15 секунд&#10;    });&#10;&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;    &#10;    if (error.response) {&#10;      throw new Error(`Ошибка сервера: ${error.response.status} ${error.response.statusText}`);&#10;    } else if (error.request) {&#10;      throw new Error('Нет ответа от сервера. Проверьте подключение к интернету.');&#10;    } else {&#10;      throw new Error(`Ошибка запроса: ${error.message}`);&#10;    }&#10;  }&#10;};&#10;&#10;export const fetchNewsById = async (id: number): Promise&lt;NewsItem&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;NewsItem&gt;(`${API_URL}${id}`, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000&#10;    });&#10;&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новости:', error);&#10;    throw new Error('Не удалось загрузить новость');&#10;  }&#10;};&#10;&#10;export const fetchCategories = async (): Promise&lt;string[]&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;{status: string, data: string[]}&gt;(`${API_URL}categories/`, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000&#10;    });&#10;&#10;    return response.data.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке категорий:', error);&#10;    return ['gifts', 'crypto', 'tech', 'community', 'gaming']; // fallback&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/components/MediaViewer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/components/MediaViewer.tsx" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import styled from 'styled-components';&#10;&#10;interface MediaViewerProps {&#10;  imageUrl?: string;&#10;  videoUrl?: string;&#10;  title: string;&#10;  className?: string;&#10;}&#10;&#10;const MediaContainer = styled.div`&#10;  position: relative;&#10;  width: 100%;&#10;  border-radius: 8px;&#10;  overflow: hidden;&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;`;&#10;&#10;const MediaImage = styled.img&lt;{ $hasVideo?: boolean }&gt;`&#10;  width: 100%;&#10;  height: auto;&#10;  max-height: 200px;&#10;  object-fit: cover;&#10;  cursor: ${props =&gt; props.$hasVideo ? 'pointer' : 'default'};&#10;  transition: transform 0.2s ease;&#10;  display: block;&#10;&#10;  &amp;:hover {&#10;    transform: ${props =&gt; props.$hasVideo ? 'scale(1.02)' : 'none'};&#10;  }&#10;`;&#10;&#10;const VideoElement = styled.video`&#10;  width: 100%;&#10;  height: auto;&#10;  max-height: 300px;&#10;  background: #000;&#10;  display: block;&#10;`;&#10;&#10;const PlayButton = styled.div`&#10;  position: absolute;&#10;  top: 50%;&#10;  left: 50%;&#10;  transform: translate(-50%, -50%);&#10;  width: 50px;&#10;  height: 50px;&#10;  background: rgba(0, 0, 0, 0.7);&#10;  border-radius: 50%;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;  backdrop-filter: blur(4px);&#10;&#10;  &amp;:hover {&#10;    background: rgba(0, 0, 0, 0.8);&#10;    transform: translate(-50%, -50%) scale(1.1);&#10;  }&#10;&#10;  &amp;::before {&#10;    content: '▶️';&#10;    font-size: 18px;&#10;    margin-left: 2px;&#10;  }&#10;`;&#10;&#10;const MediaType = styled.div`&#10;  position: absolute;&#10;  top: 8px;&#10;  right: 8px;&#10;  background: rgba(0, 0, 0, 0.7);&#10;  color: white;&#10;  padding: 4px 8px;&#10;  border-radius: 4px;&#10;  font-size: 11px;&#10;  font-weight: 500;&#10;  backdrop-filter: blur(4px);&#10;`;&#10;&#10;const ErrorPlaceholder = styled.div`&#10;  width: 100%;&#10;  height: 120px;&#10;  background: var(--tg-theme-hint-color, #333);&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-size: 14px;&#10;  border-radius: 8px;&#10;`;&#10;&#10;const MediaViewer: React.FC&lt;MediaViewerProps&gt; = ({ &#10;  imageUrl, &#10;  videoUrl, &#10;  title, &#10;  className &#10;}) =&gt; {&#10;  const [isVideoPlaying, setIsVideoPlaying] = useState(false);&#10;  const [imageError, setImageError] = useState(false);&#10;&#10;  const handlePlayVideo = () =&gt; {&#10;    setIsVideoPlaying(true);&#10;  };&#10;&#10;  const handleImageError = () =&gt; {&#10;    setImageError(true);&#10;  };&#10;&#10;  if (imageError &amp;&amp; !videoUrl) {&#10;    return (&#10;      &lt;MediaContainer className={className}&gt;&#10;        &lt;ErrorPlaceholder&gt;&#10;           Изображение недоступно&#10;        &lt;/ErrorPlaceholder&gt;&#10;      &lt;/MediaContainer&gt;&#10;    );&#10;  }&#10;&#10;  if (videoUrl &amp;&amp; isVideoPlaying) {&#10;    return (&#10;      &lt;MediaContainer className={className}&gt;&#10;        &lt;VideoElement&#10;          controls&#10;          autoPlay&#10;          poster={imageUrl}&#10;          onError={() =&gt; setIsVideoPlaying(false)}&#10;        &gt;&#10;          &lt;source src={videoUrl} type=&quot;video/mp4&quot; /&gt;&#10;          &lt;source src={videoUrl} type=&quot;video/webm&quot; /&gt;&#10;          Ваш браузер не поддерживает воспроизведение видео.&#10;        &lt;/VideoElement&gt;&#10;        &lt;MediaType&gt; ВИДЕО&lt;/MediaType&gt;&#10;      &lt;/MediaContainer&gt;&#10;    );&#10;  }&#10;&#10;  if (imageUrl) {&#10;    return (&#10;      &lt;MediaContainer className={className}&gt;&#10;        &lt;MediaImage&#10;          src={imageUrl}&#10;          alt={title}&#10;          $hasVideo={!!videoUrl}&#10;          onError={handleImageError}&#10;          onClick={videoUrl ? handlePlayVideo : undefined}&#10;        /&gt;&#10;        {videoUrl &amp;&amp; (&#10;          &lt;&gt;&#10;            &lt;PlayButton onClick={handlePlayVideo} /&gt;&#10;            &lt;MediaType&gt; ВИДЕО&lt;/MediaType&gt;&#10;          &lt;/&gt;&#10;        )}&#10;        {!videoUrl &amp;&amp; (&#10;          &lt;MediaType&gt; ФОТО&lt;/MediaType&gt;&#10;        )}&#10;      &lt;/MediaContainer&gt;&#10;    );&#10;  }&#10;&#10;  return null;&#10;};&#10;&#10;export default MediaViewer;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/components/NewsModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/components/NewsModal.tsx" />
              <option name="originalContent" value="import React, { useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import TelegramWebApp from '../telegram/TelegramWebApp';&#10;&#10;interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  image_url?: string;&#10;  video_url?: string;&#10;  reading_time?: number;&#10;  views_count?: number;&#10;  author?: string;&#10;  subtitle?: string;&#10;}&#10;&#10;interface NewsModalProps {&#10;  news: NewsItem;&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;}&#10;&#10;const ModalOverlay = styled.div&lt;{ $isOpen: boolean }&gt;`&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background: rgba(0, 0, 0, 0.8);&#10;  backdrop-filter: blur(10px);&#10;  z-index: 1000;&#10;  opacity: ${props =&gt; props.$isOpen ? 1 : 0};&#10;  visibility: ${props =&gt; props.$isOpen ? 'visible' : 'hidden'};&#10;  transition: all 0.3s ease;&#10;`;&#10;&#10;const ModalContainer = styled.div&lt;{ $isOpen: boolean }&gt;`&#10;  position: fixed;&#10;  top: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  left: 0;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  transform: translateY(${props =&gt; props.$isOpen ? '0' : '100%'});&#10;  transition: transform 0.3s ease;&#10;  overflow-y: auto;&#10;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;&#10;`;&#10;&#10;const ModalHeader = styled.header`&#10;  position: sticky;&#10;  top: 0;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #333);&#10;  padding: 16px;&#10;  z-index: 100;&#10;  backdrop-filter: blur(10px);&#10;`;&#10;&#10;const HeaderControls = styled.div`&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const CloseButton = styled.button`&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 50%;&#10;  width: 40px;&#10;  height: 40px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  cursor: pointer;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-size: 18px;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    background: var(--tg-theme-hint-color, #333);&#10;    transform: scale(1.05);&#10;  }&#10;&#10;  &amp;:active {&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;const ShareButton = styled.button`&#10;  background: var(--tg-theme-button-color, #0088cc);&#10;  border: none;&#10;  border-radius: 20px;&#10;  padding: 8px 16px;&#10;  color: var(--tg-theme-button-text-color, #ffffff);&#10;  font-size: 14px;&#10;  font-weight: 500;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-1px);&#10;    box-shadow: 0 4px 12px rgba(0, 136, 204, 0.3);&#10;  }&#10;&#10;  &amp;:active {&#10;    transform: translateY(0);&#10;  }&#10;`;&#10;&#10;const ArticleHeader = styled.div`&#10;  margin-bottom: 16px;&#10;`;&#10;&#10;const CategoryBadge = styled.span&lt;{ $category: string }&gt;`&#10;  display: inline-block;&#10;  padding: 6px 12px;&#10;  border-radius: 20px;&#10;  font-size: 12px;&#10;  font-weight: 600;&#10;  background: ${props =&gt; getCategoryColor(props.$category)};&#10;  color: #ffffff;&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const ArticleTitle = styled.h1`&#10;  margin: 0 0 8px 0;&#10;  font-size: 24px;&#10;  font-weight: 700;&#10;  line-height: 1.3;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;`;&#10;&#10;const ArticleSubtitle = styled.h2`&#10;  margin: 0 0 16px 0;&#10;  font-size: 18px;&#10;  font-weight: 400;&#10;  line-height: 1.4;&#10;  color: var(--tg-theme-hint-color, #999);&#10;`;&#10;&#10;const ArticleMetadata = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 16px;&#10;  font-size: 14px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  padding-bottom: 16px;&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #333);&#10;`;&#10;&#10;const MetadataItem = styled.span`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 6px;&#10;`;&#10;&#10;const ArticleContent = styled.div`&#10;  padding: 24px 16px;&#10;  max-width: 700px;&#10;  margin: 0 auto;&#10;`;&#10;&#10;const ArticleImage = styled.img`&#10;  width: 100%;&#10;  height: auto;&#10;  border-radius: 12px;&#10;  margin: 20px 0;&#10;  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);&#10;`;&#10;&#10;const VideoContainer = styled.div`&#10;  width: 100%;&#10;  margin: 20px 0;&#10;  border-radius: 12px;&#10;  overflow: hidden;&#10;  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);&#10;`;&#10;&#10;const ArticleText = styled.div`&#10;  font-size: 16px;&#10;  line-height: 1.6;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;&#10;  p {&#10;    margin: 0 0 16px 0;&#10;  }&#10;&#10;  a {&#10;    color: var(--tg-theme-link-color, #0088cc);&#10;    text-decoration: none;&#10;&#10;    &amp;:hover {&#10;      text-decoration: underline;&#10;    }&#10;  }&#10;`;&#10;&#10;const SourceLink = styled.div`&#10;  margin-top: 32px;&#10;  padding: 16px;&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 12px;&#10;  font-size: 14px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  text-align: center;&#10;`;&#10;&#10;const SourceLinkButton = styled.button`&#10;  background: transparent;&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 8px;&#10;  padding: 8px 16px;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-size: 14px;&#10;  cursor: pointer;&#10;  margin-top: 8px;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    border-color: var(--tg-theme-button-color, #0088cc);&#10;    color: var(--tg-theme-button-color, #0088cc);&#10;  }&#10;`;&#10;&#10;const RecommendationsSection = styled.div`&#10;  margin-top: 32px;&#10;  padding: 20px 16px;&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  border-top: 1px solid var(--tg-theme-hint-color, #333);&#10;`;&#10;&#10;const RecommendationsTitle = styled.h3`&#10;  margin: 0 0 16px 0;&#10;  font-size: 18px;&#10;  font-weight: 600;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  text-align: center;&#10;`;&#10;&#10;const RecommendationCard = styled.div`&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 8px;&#10;  padding: 12px;&#10;  margin-bottom: 8px;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    border-color: var(--tg-theme-button-color, #0088cc);&#10;    transform: translateY(-1px);&#10;  }&#10;`;&#10;&#10;const RecommendationTitle = styled.h4`&#10;  margin: 0 0 4px 0;&#10;  font-size: 14px;&#10;  font-weight: 500;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  line-height: 1.3;&#10;`;&#10;&#10;const RecommendationMeta = styled.div`&#10;  font-size: 12px;&#10;  color: var(--tg-theme-hint-color, #999);&#10;`;&#10;&#10;function getCategoryColor(category: string): string {&#10;  const colors: Record&lt;string, string&gt; = {&#10;    'gifts': '#ff6b6b',&#10;    'crypto': '#4ecdc4',&#10;    'tech': '#45b7d1',&#10;    'community': '#96ceb4',&#10;    'gaming': '#feca57',&#10;    'news': '#ff9ff3',&#10;    'default': '#6c5ce7'&#10;  };&#10;  return colors[category] || colors.default;&#10;}&#10;&#10;function formatTimeAgo(dateString: string): string {&#10;  const now = new Date();&#10;  const date = new Date(dateString);&#10;  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);&#10;&#10;  if (diffInSeconds &lt; 60) return 'только что';&#10;  if (diffInSeconds &lt; 3600) return `${Math.floor(diffInSeconds / 60)} мин назад`;&#10;  if (diffInSeconds &lt; 86400) return `${Math.floor(diffInSeconds / 3600)} ч назад`;&#10;  return `${Math.floor(diffInSeconds / 86400)} дн назад`;&#10;}&#10;&#10;function estimateReadingTime(text: string): number {&#10;  const wordsPerMinute = 200;&#10;  const words = text.split(' ').length;&#10;  return Math.ceil(words / wordsPerMinute);&#10;}&#10;&#10;const NewsModal: React.FC&lt;NewsModalProps&gt; = ({ news, isOpen, onClose }) =&gt; {&#10;  useEffect(() =&gt; {&#10;    if (isOpen) {&#10;      TelegramWebApp.triggerHapticFeedback('notification');&#10;    }&#10;  }, [isOpen]);&#10;&#10;  const handleShare = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    if (navigator.share) {&#10;      navigator.share({&#10;        title: news.title,&#10;        text: news.content.substring(0, 100) + '...',&#10;        url: news.link&#10;      });&#10;    } else {&#10;      // Fallback для старых браузеров&#10;      navigator.clipboard.writeText(news.link);&#10;      TelegramWebApp.showAlert('Ссылка скопирована в буфер обмена');&#10;    }&#10;  };&#10;&#10;  const handleSourceClick = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    TelegramWebApp.openLink(news.link);&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    onClose();&#10;  };&#10;&#10;  if (!isOpen) return null;&#10;&#10;  const readingTime = news.reading_time || estimateReadingTime(news.content);&#10;&#10;  return (&#10;    &lt;ModalOverlay $isOpen={isOpen} onClick={handleClose}&gt;&#10;      &lt;ModalContainer $isOpen={isOpen} onClick={(e) =&gt; e.stopPropagation()}&gt;&#10;        &lt;ModalHeader&gt;&#10;          &lt;HeaderControls&gt;&#10;            &lt;CloseButton onClick={handleClose}&gt;×&lt;/CloseButton&gt;&#10;            &lt;ShareButton onClick={handleShare}&gt;Поделиться&lt;/ShareButton&gt;&#10;          &lt;/HeaderControls&gt;&#10;&#10;          &lt;ArticleHeader&gt;&#10;            &lt;CategoryBadge $category={news.category}&gt;&#10;              {news.category.toUpperCase()}&#10;            &lt;/CategoryBadge&gt;&#10;&#10;            &lt;ArticleTitle&gt;{news.title}&lt;/ArticleTitle&gt;&#10;&#10;            {news.subtitle &amp;&amp; (&#10;              &lt;ArticleSubtitle&gt;{news.subtitle}&lt;/ArticleSubtitle&gt;&#10;            )}&#10;&#10;            &lt;ArticleMetadata&gt;&#10;              &lt;MetadataItem&gt;&#10;                 {formatTimeAgo(news.publish_date)}&#10;              &lt;/MetadataItem&gt;&#10;&#10;              &lt;MetadataItem&gt;&#10;                 {readingTime} мин чтения&#10;              &lt;/MetadataItem&gt;&#10;&#10;              {news.views_count !== undefined &amp;&amp; (&#10;                &lt;MetadataItem&gt;&#10;                  ️ {news.views_count} просмотров&#10;                &lt;/MetadataItem&gt;&#10;              )}&#10;&#10;              {news.author &amp;&amp; (&#10;                &lt;MetadataItem&gt;&#10;                   {news.author}&#10;                &lt;/MetadataItem&gt;&#10;              )}&#10;            &lt;/ArticleMetadata&gt;&#10;          &lt;/ArticleHeader&gt;&#10;        &lt;/ModalHeader&gt;&#10;&#10;        &lt;ArticleContent&gt;&#10;          {news.image_url &amp;&amp; (&#10;            &lt;ArticleImage&#10;              src={news.image_url}&#10;              alt={news.title}&#10;              onError={(e) =&gt; {&#10;                e.currentTarget.style.display = 'none';&#10;              }}&#10;            /&gt;&#10;          )}&#10;&#10;          {news.video_url &amp;&amp; (&#10;            &lt;VideoContainer&gt;&#10;              &lt;video&#10;                controls&#10;                style={{ width: '100%', height: 'auto' }}&#10;                poster={news.image_url}&#10;              &gt;&#10;                &lt;source src={news.video_url} type=&quot;video/mp4&quot; /&gt;&#10;                Ваш браузер не поддерживает видео.&#10;              &lt;/video&gt;&#10;            &lt;/VideoContainer&gt;&#10;          )}&#10;&#10;          &lt;ArticleText&gt;&#10;            {news.content.split('\n').map((paragraph, index) =&gt;&#10;              paragraph.trim() &amp;&amp; (&#10;                &lt;p key={index}&gt;{paragraph}&lt;/p&gt;&#10;              )&#10;            )}&#10;          &lt;/ArticleText&gt;&#10;&#10;          &lt;SourceLink&gt;&#10;            Источник&#10;            &lt;SourceLinkButton onClick={handleSourceClick}&gt;&#10;              Читать оригинал&#10;            &lt;/SourceLinkButton&gt;&#10;          &lt;/SourceLink&gt;&#10;        &lt;/ArticleContent&gt;&#10;&#10;        &lt;RecommendationsSection&gt;&#10;          &lt;RecommendationsTitle&gt;Рекомендуем к прочтению&lt;/RecommendationsTitle&gt;&#10;&#10;          {/* Здесь можно добавить рекомендованные статьи */}&#10;          &lt;RecommendationCard&gt;&#10;            &lt;RecommendationTitle&gt;&#10;              Похожие новости появятся здесь&#10;            &lt;/RecommendationTitle&gt;&#10;            &lt;RecommendationMeta&gt;&#10;              Система рекомендаций в разработке&#10;            &lt;/RecommendationMeta&gt;&#10;          &lt;/RecommendationCard&gt;&#10;        &lt;/RecommendationsSection&gt;&#10;      &lt;/ModalContainer&gt;&#10;    &lt;/ModalOverlay&gt;&#10;  );&#10;};&#10;&#10;export default NewsModal;&#10;" />
              <option name="updatedContent" value="import React, { useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import MediaViewer from './MediaViewer';&#10;import TelegramWebApp from '../telegram/TelegramWebApp';&#10;&#10;interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  image_url?: string;&#10;  video_url?: string;&#10;  reading_time?: number;&#10;  views_count?: number;&#10;  author?: string;&#10;  subtitle?: string;&#10;}&#10;&#10;interface NewsModalProps {&#10;  news: NewsItem;&#10;  isOpen: boolean;&#10;  onClose: () =&gt; void;&#10;}&#10;&#10;const ModalOverlay = styled.div&lt;{ $isOpen: boolean }&gt;`&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background: rgba(0, 0, 0, 0.9);&#10;  backdrop-filter: blur(10px);&#10;  z-index: 1000;&#10;  opacity: ${props =&gt; props.$isOpen ? 1 : 0};&#10;  visibility: ${props =&gt; props.$isOpen ? 'visible' : 'hidden'};&#10;  transition: all 0.3s ease;&#10;`;&#10;&#10;const ModalContainer = styled.div&lt;{ $isOpen: boolean }&gt;`&#10;  position: fixed;&#10;  top: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  left: 0;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  transform: translateY(${props =&gt; props.$isOpen ? '0' : '100%'});&#10;  transition: transform 0.3s ease;&#10;  overflow-y: auto;&#10;  display: flex;&#10;  flex-direction: column;&#10;`;&#10;&#10;const ModalHeader = styled.div`&#10;  position: sticky;&#10;  top: 0;&#10;  background: var(--tg-theme-bg-color, #0f0f0f);&#10;  padding: 12px 16px;&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #333);&#10;  backdrop-filter: blur(10px);&#10;  z-index: 10;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;`;&#10;&#10;const BackButton = styled.button`&#10;  background: none;&#10;  border: none;&#10;  color: var(--tg-theme-button-color, #0088cc);&#10;  font-size: 16px;&#10;  cursor: pointer;&#10;  padding: 8px;&#10;  margin: -8px;&#10;  border-radius: 6px;&#10;  transition: background 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  }&#10;`;&#10;&#10;const ShareButton = styled.button`&#10;  background: none;&#10;  border: none;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-size: 16px;&#10;  cursor: pointer;&#10;  padding: 8px;&#10;  margin: -8px;&#10;  border-radius: 6px;&#10;  transition: background 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  }&#10;`;&#10;&#10;const ModalContent = styled.div`&#10;  flex: 1;&#10;  padding: 0 16px 40px 16px;&#10;  max-width: 800px;&#10;  margin: 0 auto;&#10;  width: 100%;&#10;`;&#10;&#10;const ArticleHeader = styled.div`&#10;  margin: 20px 0;&#10;`;&#10;&#10;const CategoryBadge = styled.span`&#10;  display: inline-block;&#10;  padding: 4px 8px;&#10;  background: var(--tg-theme-button-color, #0088cc);&#10;  color: var(--tg-theme-button-text-color, #ffffff);&#10;  border-radius: 4px;&#10;  font-size: 11px;&#10;  font-weight: 500;&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const ArticleTitle = styled.h1`&#10;  font-size: 24px;&#10;  font-weight: 700;&#10;  line-height: 1.3;&#10;  margin: 0 0 16px 0;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;`;&#10;&#10;const ArticleSubtitle = styled.p`&#10;  font-size: 16px;&#10;  line-height: 1.5;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  margin: 0 0 20px 0;&#10;`;&#10;&#10;const ArticleMeta = styled.div`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 16px;&#10;  margin-bottom: 24px;&#10;  font-size: 13px;&#10;  color: var(--tg-theme-hint-color, #888);&#10;  flex-wrap: wrap;&#10;`;&#10;&#10;const MetaItem = styled.span`&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 4px;&#10;`;&#10;&#10;const ArticleContent = styled.div`&#10;  font-size: 16px;&#10;  line-height: 1.6;&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;&#10;  p {&#10;    margin: 0 0 16px 0;&#10;  }&#10;&#10;  h2, h3, h4 {&#10;    margin: 24px 0 12px 0;&#10;    color: var(--tg-theme-text-color, #ffffff);&#10;  }&#10;&#10;  ul, ol {&#10;    margin: 0 0 16px 0;&#10;    padding-left: 20px;&#10;  }&#10;&#10;  blockquote {&#10;    margin: 16px 0;&#10;    padding: 12px 16px;&#10;    background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;    border-left: 4px solid var(--tg-theme-button-color, #0088cc);&#10;    border-radius: 0 4px 4px 0;&#10;  }&#10;&#10;  code {&#10;    background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;    padding: 2px 4px;&#10;    border-radius: 4px;&#10;    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;&#10;    font-size: 14px;&#10;  }&#10;`;&#10;&#10;const InteractionBar = styled.div`&#10;  margin-top: 32px;&#10;  padding: 16px 0;&#10;  border-top: 1px solid var(--tg-theme-hint-color, #333);&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: space-between;&#10;`;&#10;&#10;const InteractionButtons = styled.div`&#10;  display: flex;&#10;  gap: 20px;&#10;`;&#10;&#10;const InteractionButton = styled.button`&#10;  background: none;&#10;  border: none;&#10;  color: var(--tg-theme-hint-color, #888);&#10;  font-size: 14px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 6px;&#10;  padding: 8px 12px;&#10;  border-radius: 6px;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;    color: var(--tg-theme-text-color, #ffffff);&#10;  }&#10;&#10;  &amp;.active {&#10;    color: var(--tg-theme-button-color, #0088cc);&#10;  }&#10;`;&#10;&#10;const ReadOriginalButton = styled.a`&#10;  display: inline-flex;&#10;  align-items: center;&#10;  gap: 8px;&#10;  padding: 12px 20px;&#10;  background: var(--tg-theme-button-color, #0088cc);&#10;  color: var(--tg-theme-button-text-color, #ffffff);&#10;  text-decoration: none;&#10;  border-radius: 8px;&#10;  font-weight: 500;&#10;  transition: background 0.2s ease;&#10;&#10;  &amp;:hover {&#10;    background: #0077b3;&#10;  }&#10;`;&#10;&#10;const formatTimeAgo = (dateString: string): string =&gt; {&#10;  const now = new Date();&#10;  const date = new Date(dateString);&#10;  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);&#10;&#10;  if (diffInSeconds &lt; 60) return 'только что';&#10;  if (diffInSeconds &lt; 3600) return `${Math.floor(diffInSeconds / 60)} мин назад`;&#10;  if (diffInSeconds &lt; 86400) return `${Math.floor(diffInSeconds / 3600)} ч назад`;&#10;  return `${Math.floor(diffInSeconds / 86400)} дн назад`;&#10;};&#10;&#10;const NewsModal: React.FC&lt;NewsModalProps&gt; = ({ news, isOpen, onClose }) =&gt; {&#10;  useEffect(() =&gt; {&#10;    if (isOpen) {&#10;      document.body.style.overflow = 'hidden';&#10;      TelegramWebApp.expand();&#10;    } else {&#10;      document.body.style.overflow = 'auto';&#10;    }&#10;&#10;    return () =&gt; {&#10;      document.body.style.overflow = 'auto';&#10;    };&#10;  }, [isOpen]);&#10;&#10;  useEffect(() =&gt; {&#10;    const handleEscape = (e: KeyboardEvent) =&gt; {&#10;      if (e.key === 'Escape') {&#10;        onClose();&#10;      }&#10;    };&#10;&#10;    if (isOpen) {&#10;      document.addEventListener('keydown', handleEscape);&#10;    }&#10;&#10;    return () =&gt; {&#10;      document.removeEventListener('keydown', handleEscape);&#10;    };&#10;  }, [isOpen, onClose]);&#10;&#10;  const handleBackClick = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    onClose();&#10;  };&#10;&#10;  const handleShare = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    if (navigator.share) {&#10;      navigator.share({&#10;        title: news.title,&#10;        text: news.content.substring(0, 200) + '...',&#10;        url: news.link&#10;      });&#10;    }&#10;  };&#10;&#10;  const handleInteraction = (type: string) =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('impact');&#10;    // Здесь можно добавить логику для лайков, закладок и т.д.&#10;    console.log(`Interaction: ${type}`);&#10;  };&#10;&#10;  return (&#10;    &lt;ModalOverlay $isOpen={isOpen} onClick={onClose}&gt;&#10;      &lt;ModalContainer $isOpen={isOpen} onClick={(e) =&gt; e.stopPropagation()}&gt;&#10;        &lt;ModalHeader&gt;&#10;          &lt;BackButton onClick={handleBackClick}&gt;&#10;            ← Назад&#10;          &lt;/BackButton&gt;&#10;          &lt;ShareButton onClick={handleShare}&gt;&#10;            &#10;          &lt;/ShareButton&gt;&#10;        &lt;/ModalHeader&gt;&#10;&#10;        &lt;ModalContent&gt;&#10;          &lt;ArticleHeader&gt;&#10;            &lt;CategoryBadge&gt;{news.category.toUpperCase()}&lt;/CategoryBadge&gt;&#10;            &lt;ArticleTitle&gt;{news.title}&lt;/ArticleTitle&gt;&#10;            {news.subtitle &amp;&amp; (&#10;              &lt;ArticleSubtitle&gt;{news.subtitle}&lt;/ArticleSubtitle&gt;&#10;            )}&#10;&#10;            &lt;ArticleMeta&gt;&#10;              {news.author &amp;&amp; (&#10;                &lt;MetaItem&gt;&#10;                   {news.author}&#10;                &lt;/MetaItem&gt;&#10;              )}&#10;              &lt;MetaItem&gt;&#10;                 {formatTimeAgo(news.publish_date)}&#10;              &lt;/MetaItem&gt;&#10;              {news.reading_time &amp;&amp; (&#10;                &lt;MetaItem&gt;&#10;                   {news.reading_time} мин чтения&#10;                &lt;/MetaItem&gt;&#10;              )}&#10;              {news.views_count !== undefined &amp;&amp; (&#10;                &lt;MetaItem&gt;&#10;                  ️ {news.views_count} просмотров&#10;                &lt;/MetaItem&gt;&#10;              )}&#10;            &lt;/ArticleMeta&gt;&#10;          &lt;/ArticleHeader&gt;&#10;&#10;          {(news.image_url || news.video_url) &amp;&amp; (&#10;            &lt;MediaViewer&#10;              imageUrl={news.image_url}&#10;              videoUrl={news.video_url}&#10;              title={news.title}&#10;            /&gt;&#10;          )}&#10;&#10;          &lt;ArticleContent&gt;&#10;            {news.content.split('\n').map((paragraph, index) =&gt; (&#10;              &lt;p key={index}&gt;{paragraph}&lt;/p&gt;&#10;            ))}&#10;          &lt;/ArticleContent&gt;&#10;&#10;          &lt;InteractionBar&gt;&#10;            &lt;InteractionButtons&gt;&#10;              &lt;InteractionButton onClick={() =&gt; handleInteraction('like')}&gt;&#10;                 +2&#10;              &lt;/InteractionButton&gt;&#10;              &lt;InteractionButton onClick={() =&gt; handleInteraction('comment')}&gt;&#10;                 0&#10;              &lt;/InteractionButton&gt;&#10;              &lt;InteractionButton onClick={() =&gt; handleInteraction('bookmark')}&gt;&#10;                 3&#10;              &lt;/InteractionButton&gt;&#10;            &lt;/InteractionButtons&gt;&#10;&#10;            &lt;ReadOriginalButton href={news.link} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#10;              Читать оригинал &#10;            &lt;/ReadOriginalButton&gt;&#10;          &lt;/InteractionBar&gt;&#10;        &lt;/ModalContent&gt;&#10;      &lt;/ModalContainer&gt;&#10;    &lt;/ModalOverlay&gt;&#10;  );&#10;};&#10;&#10;export default NewsModal;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/components/SearchBar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/components/SearchBar.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import styled from 'styled-components';&#10;&#10;interface SearchBarProps {&#10;  value: string;&#10;  onChange: (value: string) =&gt; void;&#10;  placeholder?: string;&#10;}&#10;&#10;const SearchContainer = styled.div`&#10;  position: relative;&#10;  margin-bottom: 12px;&#10;`;&#10;&#10;const SearchInput = styled.input`&#10;  width: 100%;&#10;  padding: 10px 16px 10px 40px;&#10;  border: 1px solid var(--tg-theme-hint-color, #333);&#10;  border-radius: 8px;&#10;  background: var(--tg-theme-secondary-bg-color, #1a1a1a);&#10;  color: var(--tg-theme-text-color, #ffffff);&#10;  font-size: 14px;&#10;  font-family: inherit;&#10;  transition: all 0.2s ease;&#10;  box-sizing: border-box;&#10;&#10;  &amp;::placeholder {&#10;    color: var(--tg-theme-hint-color, #999);&#10;  }&#10;&#10;  &amp;:focus {&#10;    outline: none;&#10;    border-color: var(--tg-theme-button-color, #0088cc);&#10;    box-shadow: 0 0 0 3px rgba(0, 136, 204, 0.1);&#10;  }&#10;&#10;  &amp;:hover {&#10;    border-color: var(--tg-theme-button-color, #0088cc);&#10;  }&#10;`;&#10;&#10;const SearchIcon = styled.div`&#10;  position: absolute;&#10;  left: 12px;&#10;  top: 50%;&#10;  transform: translateY(-50%);&#10;  color: var(--tg-theme-hint-color, #999);&#10;  font-size: 16px;&#10;  pointer-events: none;&#10;`;&#10;&#10;const ClearButton = styled.button&lt;{ $visible: boolean }&gt;`&#10;  position: absolute;&#10;  right: 12px;&#10;  top: 50%;&#10;  transform: translateY(-50%);&#10;  background: none;&#10;  border: none;&#10;  color: var(--tg-theme-hint-color, #999);&#10;  cursor: pointer;&#10;  font-size: 16px;&#10;  opacity: ${props =&gt; props.$visible ? 1 : 0};&#10;  transition: all 0.2s ease;&#10;  padding: 0;&#10;  width: 20px;&#10;  height: 20px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;&#10;  &amp;:hover {&#10;    color: var(--tg-theme-text-color, #ffffff);&#10;  }&#10;`;&#10;&#10;const SearchBar: React.FC&lt;SearchBarProps&gt; = ({ &#10;  value, &#10;  onChange, &#10;  placeholder = &quot;Поиск...&quot; &#10;}) =&gt; {&#10;  const handleClear = () =&gt; {&#10;    onChange('');&#10;  };&#10;&#10;  return (&#10;    &lt;SearchContainer&gt;&#10;      &lt;SearchIcon&gt;&lt;/SearchIcon&gt;&#10;      &lt;SearchInput&#10;        type=&quot;text&quot;&#10;        value={value}&#10;        onChange={(e) =&gt; onChange(e.target.value)}&#10;        placeholder={placeholder}&#10;      /&gt;&#10;      &lt;ClearButton&#10;        $visible={value.length &gt; 0}&#10;        onClick={handleClear}&#10;        type=&quot;button&quot;&#10;      &gt;&#10;        ✕&#10;      &lt;/ClearButton&gt;&#10;    &lt;/SearchContainer&gt;&#10;  );&#10;};&#10;&#10;export default SearchBar;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts" />
              <option name="updatedContent" value="// Telegram WebApp API для React&#10;class TelegramWebApp {&#10;  private webApp: any = null;&#10;&#10;  init() {&#10;    // Проверяем, что мы внутри Telegram&#10;    if (typeof window !== 'undefined' &amp;&amp; window.Telegram?.WebApp) {&#10;      this.webApp = window.Telegram.WebApp;&#10;      this.webApp.ready();&#10;      this.webApp.expand();&#10;&#10;      // Настройка темы&#10;      this.webApp.setHeaderColor('#1a1a1a');&#10;      this.webApp.setBackgroundColor('#1a1a1a');&#10;&#10;      console.log('Telegram WebApp инициализирован');&#10;    } else {&#10;      console.log('Telegram WebApp недоступен - работаем в браузере');&#10;    }&#10;  }&#10;&#10;  isAvailable(): boolean {&#10;    return this.webApp !== null;&#10;  }&#10;&#10;  expand() {&#10;    if (this.webApp &amp;&amp; this.webApp.expand) {&#10;      this.webApp.expand();&#10;    }&#10;  }&#10;&#10;  getThemeParams() {&#10;    if (this.webApp) {&#10;      return this.webApp.themeParams;&#10;    }&#10;    return {&#10;      bg_color: '#1a1a1a',&#10;      text_color: '#ffffff',&#10;      hint_color: '#999999',&#10;      link_color: '#0088cc',&#10;      button_color: '#0088cc',&#10;      button_text_color: '#ffffff'&#10;    };&#10;  }&#10;&#10;  getUserData() {&#10;    if (this.webApp &amp;&amp; this.webApp.initDataUnsafe) {&#10;      return this.webApp.initDataUnsafe.user;&#10;    }&#10;    return null;&#10;  }&#10;&#10;  triggerHapticFeedback(type: 'impact' | 'notification' = 'impact') {&#10;    if (this.webApp &amp;&amp; this.webApp.HapticFeedback) {&#10;      if (type === 'impact') {&#10;        this.webApp.HapticFeedback.impactOccurred('light');&#10;      } else if (type === 'notification') {&#10;        this.webApp.HapticFeedback.notificationOccurred('success');&#10;      }&#10;    }&#10;  }&#10;&#10;  showPopup(title: string, message: string, buttons?: any[]) {&#10;    if (this.webApp &amp;&amp; this.webApp.showPopup) {&#10;      return this.webApp.showPopup({&#10;        title,&#10;        message,&#10;        buttons: buttons || [{ type: 'ok' }]&#10;      });&#10;    }&#10;  }&#10;&#10;  close() {&#10;    if (this.webApp &amp;&amp; this.webApp.close) {&#10;      this.webApp.close();&#10;    }&#10;  }&#10;&#10;  openLink(url: string) {&#10;    if (this.webApp &amp;&amp; this.webApp.openLink) {&#10;      this.webApp.openLink(url);&#10;    } else {&#10;      window.open(url, '_blank');&#10;    }&#10;  }&#10;&#10;  setMainButton(text: string, callback?: () =&gt; void) {&#10;    if (this.webApp &amp;&amp; this.webApp.MainButton) {&#10;      this.webApp.MainButton.text = text;&#10;      this.webApp.MainButton.show();&#10;      &#10;      if (callback) {&#10;        this.webApp.MainButton.onClick(callback);&#10;      }&#10;    }&#10;  }&#10;&#10;  hideMainButton() {&#10;    if (this.webApp &amp;&amp; this.webApp.MainButton) {&#10;      this.webApp.MainButton.hide();&#10;    }&#10;  }&#10;}&#10;&#10;// Создаем единственный экземпляр&#10;const telegramWebApp = new TelegramWebApp();&#10;&#10;export default telegramWebApp;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/telegram-webapp.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/telegram-webapp.d.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="// Типы для Telegram WebApp API&#13;&#10;declare global {&#13;&#10;  interface Window {&#13;&#10;    Telegram?: {&#13;&#10;      WebApp: {&#13;&#10;        ready(): void;&#13;&#10;        expand(): void;&#13;&#10;        close(): void;&#13;&#10;        setHeaderColor(color: string): void;&#13;&#10;        setBackgroundColor(color: string): void;&#13;&#10;        showAlert(message: string): void;&#13;&#10;        showConfirm(message: string, callback: (confirmed: boolean) =&gt; void): void;&#13;&#10;        openLink(url: string): void;&#13;&#10;        onEvent(eventType: string, callback: () =&gt; void): void;&#13;&#10;        offEvent(eventType: string, callback: () =&gt; void): void;&#13;&#10;        isExpanded: boolean;&#13;&#10;        viewportHeight: number;&#13;&#10;        themeParams: {&#13;&#10;          bg_color?: string;&#13;&#10;          text_color?: string;&#13;&#10;          hint_color?: string;&#13;&#10;          link_color?: string;&#13;&#10;          button_color?: string;&#13;&#10;          button_text_color?: string;&#13;&#10;          secondary_bg_color?: string;&#13;&#10;          destructive_text_color?: string;&#13;&#10;        };&#13;&#10;        initDataUnsafe?: {&#13;&#10;          user?: {&#13;&#10;            id: number;&#13;&#10;            first_name: string;&#13;&#10;            last_name?: string;&#13;&#10;            username?: string;&#13;&#10;            language_code?: string;&#13;&#10;          };&#13;&#10;        };&#13;&#10;        HapticFeedback?: {&#13;&#10;          impactOccurred(style: 'light' | 'medium' | 'heavy' | 'rigid' | 'soft'): void;&#13;&#10;          notificationOccurred(type: 'error' | 'success' | 'warning'): void;&#13;&#10;          selectionChanged(): void;&#13;&#10;        };&#13;&#10;        initData: string;&#13;&#10;        version: string;&#13;&#10;        platform: string;&#13;&#10;        colorScheme: 'light' | 'dark';&#13;&#10;        isClosingConfirmationEnabled: boolean;&#13;&#10;        sendData(data: string): void;&#13;&#10;        openTelegramLink(url: string): void;&#13;&#10;        openInvoice(url: string, callback?: (status: string) =&gt; void): void;&#13;&#10;        showPopup(params: {&#13;&#10;          title?: string;&#13;&#10;          message: string;&#13;&#10;          buttons?: Array&lt;{&#13;&#10;            id?: string;&#13;&#10;            type?: 'default' | 'ok' | 'close' | 'cancel' | 'destructive';&#13;&#10;            text: string;&#13;&#10;          }&gt;;&#13;&#10;        }, callback?: (buttonId: string) =&gt; void): void;&#13;&#10;        showScanQrPopup(params: { text?: string }, callback?: (text: string) =&gt; void): void;&#13;&#10;        closeScanQrPopup(): void;&#13;&#10;        readTextFromClipboard(callback?: (text: string) =&gt; void): void;&#13;&#10;        requestWriteAccess(callback?: (granted: boolean) =&gt; void): void;&#13;&#10;        requestContact(callback?: (granted: boolean) =&gt; void): void;&#13;&#10;        requestLocation(callback?: (granted: boolean) =&gt; void): void;&#13;&#10;        isVersionAtLeast(version: string): boolean;&#13;&#10;        BackButton: {&#13;&#10;          isVisible: boolean;&#13;&#10;          onClick(callback: () =&gt; void): void;&#13;&#10;          offClick(callback: () =&gt; void): void;&#13;&#10;          show(): void;&#13;&#10;          hide(): void;&#13;&#10;        };&#13;&#10;        MainButton: {&#13;&#10;          text: string;&#13;&#10;          color: string;&#13;&#10;          textColor: string;&#13;&#10;          isVisible: boolean;&#13;&#10;          isActive: boolean;&#13;&#10;          isProgressVisible: boolean;&#13;&#10;          setText(text: string): void;&#13;&#10;          onClick(callback: () =&gt; void): void;&#13;&#10;          offClick(callback: () =&gt; void): void;&#13;&#10;          show(): void;&#13;&#10;          hide(): void;&#13;&#10;          enable(): void;&#13;&#10;          disable(): void;&#13;&#10;          showProgress(leaveActive?: boolean): void;&#13;&#10;          hideProgress(): void;&#13;&#10;          setParams(params: {&#13;&#10;            text?: string;&#13;&#10;            color?: string;&#13;&#10;            text_color?: string;&#13;&#10;            is_active?: boolean;&#13;&#10;            is_visible?: boolean;&#13;&#10;          }): void;&#13;&#10;        };&#13;&#10;        SettingsButton: {&#13;&#10;          isVisible: boolean;&#13;&#10;          onClick(callback: () =&gt; void): void;&#13;&#10;          offClick(callback: () =&gt; void): void;&#13;&#10;          show(): void;&#13;&#10;          hide(): void;&#13;&#10;        };&#13;&#10;      };&#13;&#10;    };&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;export {};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrate.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrate.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Скрипт для применения миграций базы данных&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;import asyncio&#10;from sqlalchemy import text&#10;from sqlalchemy.ext.asyncio import create_async_engine&#10;import logging&#10;&#10;# Добавляем путь к серверу для импорта модулей&#10;sys.path.append(os.path.join(os.path.dirname(__file__), 'server'))&#10;&#10;from config import DATABASE_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;async def apply_migration():&#10;    &quot;&quot;&quot;Применяет миграцию для добавления новых полей&quot;&quot;&quot;&#10;    &#10;    # Заменяем postgresql:// на postgresql+asyncpg://&#10;    async_url = DATABASE_URL.replace('postgresql://', 'postgresql+asyncpg://')&#10;    engine = create_async_engine(async_url)&#10;    &#10;    try:&#10;        async with engine.begin() as conn:&#10;            logger.info(&quot;Подключение к базе данных...&quot;)&#10;            &#10;            # Проверяем, существуют ли уже поля&#10;            result = await conn.execute(text(&quot;&quot;&quot;&#10;                SELECT column_name &#10;                FROM information_schema.columns &#10;                WHERE table_name = 'news_items' &#10;                AND column_name IN ('image_url', 'video_url', 'reading_time', 'views_count', 'author', 'subtitle')&#10;            &quot;&quot;&quot;))&#10;            &#10;            existing_columns = [row[0] for row in result.fetchall()]&#10;            logger.info(f&quot;Существующие новые поля: {existing_columns}&quot;)&#10;            &#10;            # Добавляем поля, которых еще нет&#10;            fields_to_add = [&#10;                ('image_url', 'VARCHAR(1000)'),&#10;                ('video_url', 'VARCHAR(1000)'),&#10;                ('reading_time', 'INTEGER'),&#10;                ('views_count', 'INTEGER'),&#10;                ('author', 'VARCHAR(200)'),&#10;                ('subtitle', 'VARCHAR(500)')&#10;            ]&#10;            &#10;            for field_name, field_type in fields_to_add:&#10;                if field_name not in existing_columns:&#10;                    logger.info(f&quot;Добавляем поле {field_name}...&quot;)&#10;                    await conn.execute(text(f&quot;&quot;&quot;&#10;                        ALTER TABLE news_items &#10;                        ADD COLUMN {field_name} {field_type}&#10;                    &quot;&quot;&quot;))&#10;                    logger.info(f&quot;Поле {field_name} добавлено успешно&quot;)&#10;                else:&#10;                    logger.info(f&quot;Поле {field_name} уже существует&quot;)&#10;            &#10;            logger.info(&quot;Миграция применена успешно!&quot;)&#10;            &#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при применении миграции: {e}&quot;)&#10;        raise&#10;    finally:&#10;        await engine.dispose()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    asyncio.run(apply_migration())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/001_add_media_fields.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/001_add_media_fields.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;add_media_fields_to_news_items&#10;&#10;Revision ID: 001&#10;Revises: &#10;Create Date: 2025-07-26 02:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;&#10;# revision identifiers&#10;revision = '001'&#10;down_revision = None&#10;branch_labels = None&#10;depends_on = None&#10;&#10;def upgrade():&#10;    # Добавляем новые поля в таблицу news_items&#10;    op.add_column('news_items', sa.Column('image_url', sa.String(1000), nullable=True))&#10;    op.add_column('news_items', sa.Column('video_url', sa.String(1000), nullable=True))&#10;    op.add_column('news_items', sa.Column('reading_time', sa.Integer(), nullable=True))&#10;    op.add_column('news_items', sa.Column('views_count', sa.Integer(), nullable=True))&#10;    op.add_column('news_items', sa.Column('author', sa.String(200), nullable=True))&#10;    op.add_column('news_items', sa.Column('subtitle', sa.String(500), nullable=True))&#10;&#10;def downgrade():&#10;    # Удаляем добавленные поля&#10;    op.drop_column('news_items', 'subtitle')&#10;    op.drop_column('news_items', 'author')&#10;    op.drop_column('news_items', 'views_count')&#10;    op.drop_column('news_items', 'reading_time')&#10;    op.drop_column('news_items', 'video_url')&#10;    op.drop_column('news_items', 'image_url')" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/.env" />
              <option name="updatedContent" value="# База данных&#10;DATABASE_URL=postgresql://user:password@db:5432/giftpropaganda&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=your_bot_token_here&#10;WEBHOOK_URL=https://your-domain.com/telegram_webhook&#10;&#10;# Redis (опционально)&#10;REDIS_URL=redis://localhost:6379&#10;&#10;# Другие настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/__init__.py" />
              <option name="updatedContent" value="# API package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/news.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/news.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException, Query&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import desc&#10;from typing import List, Optional&#10;from datetime import datetime&#10;import logging&#10;&#10;from server.db import get_db, NewsItem, NewsSource&#10;from server.models import NewsResponse, NewsItemResponse, MediaItem&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.get(&quot;/news/&quot;, response_model=NewsResponse)&#10;async def get_news(&#10;        category: Optional[str] = Query(None, description=&quot;Фильтр по категории&quot;),&#10;        limit: int = Query(50, description=&quot;Количество новостей&quot;, le=100),&#10;        offset: int = Query(0, description=&quot;Смещение для пагинации&quot;),&#10;        db: Session = Depends(get_db)&#10;):&#10;    &quot;&quot;&quot;Получить список новостей с фильтрацией&quot;&quot;&quot;&#10;    try:&#10;        logger.info(f&quot;Запрос новостей: category={category}, limit={limit}, offset={offset}&quot;)&#10;&#10;        # Базовый запрос&#10;        query = db.query(NewsItem)&#10;&#10;        # Фильтр по категории&#10;        if category and category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;&#10;        # Сортировка по дате публикации&#10;        query = query.order_by(desc(NewsItem.publish_date))&#10;&#10;        # Пагинация&#10;        total = query.count()&#10;        news_items = query.offset(offset).limit(limit).all()&#10;&#10;        logger.info(f&quot;Найдено {len(news_items)} новостей из {total} общих&quot;)&#10;&#10;        # Соберем source_id для всех новостей&#10;        source_ids = [item.source_id for item in news_items if item.source_id is not None]&#10;        sources = {}&#10;        if source_ids:&#10;            sources_list = db.query(NewsSource).filter(NewsSource.id.in_(source_ids)).all()&#10;            sources = {source.id: source for source in sources_list}&#10;&#10;        # Преобразование в response модель&#10;        news_data = []&#10;        for item in news_items:&#10;            try:&#10;                # Получаем медиа из JSON поля&#10;                media_list = []&#10;                if item.media:&#10;                    try:&#10;                        media_list = [MediaItem(**media) for media in item.media]&#10;                    except Exception as e:&#10;                        logger.warning(f&quot;Error parsing media for {item.id}: {e}&quot;)&#10;&#10;                # Получаем источник&#10;                source = sources.get(item.source_id)&#10;                source_name = source.name if source else None&#10;                source_url = source.url if source else None&#10;&#10;                news_data.append(NewsItemResponse(&#10;                    id=item.id,&#10;                    title=item.title or &quot;&quot;,&#10;                    content=item.content or &quot;&quot;,  # Plain text&#10;                    content_html=item.content_html or &quot;&quot;,  # HTML контент&#10;                    link=item.link or &quot;&quot;,&#10;                    publish_date=item.publish_date.isoformat() if item.publish_date else datetime.now().isoformat(),&#10;                    category=item.category or &quot;general&quot;,&#10;                    media=media_list,&#10;                    reading_time=item.reading_time,&#10;                    views_count=item.views_count or 0,&#10;                    author=item.author,&#10;                    source_name=source_name,&#10;                    source_url=source_url&#10;                ))&#10;            except Exception as e:&#10;                logger.warning(f&quot;Ошибка при обработке новости {item.id}: {e}&quot;)&#10;                continue&#10;&#10;        return NewsResponse(&#10;            data=news_data,&#10;            total=total,&#10;            page=offset // limit + 1,&#10;            pages=(total + limit - 1) // limit&#10;        )&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении новостей: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Ошибка при получении новостей: {str(e)}&quot;)&#10;&#10;&#10;@router.get(&quot;/news/{news_id}&quot;, response_model=NewsItemResponse)&#10;async def get_news_item(&#10;        news_id: int,&#10;        db: Session = Depends(get_db)&#10;):&#10;    &quot;&quot;&quot;Получить конкретную новость по ID&quot;&quot;&quot;&#10;    try:&#10;        news_item = db.query(NewsItem).filter(NewsItem.id == news_id).first()&#10;&#10;        if not news_item:&#10;            raise HTTPException(status_code=404, detail=&quot;Новость не найдена&quot;)&#10;&#10;        # Получаем источник&#10;        source = db.query(NewsSource).get(news_item.source_id) if news_item.source_id else None&#10;&#10;        # Получаем медиа&#10;        media_list = []&#10;        if news_item.media:&#10;            try:&#10;                media_list = [MediaItem(**media) for media in news_item.media]&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error parsing media for {news_item.id}: {e}&quot;)&#10;&#10;        # Увеличиваем счетчик просмотров&#10;        if news_item.views_count is None:&#10;            news_item.views_count = 0&#10;        news_item.views_count += 1&#10;        db.commit()&#10;&#10;        return NewsItemResponse(&#10;            id=news_item.id,&#10;            title=news_item.title or &quot;&quot;,&#10;            content=news_item.content or &quot;&quot;,&#10;            content_html=news_item.content_html or &quot;&quot;,&#10;            link=news_item.link or &quot;&quot;,&#10;            publish_date=news_item.publish_date.isoformat() if news_item.publish_date else datetime.now().isoformat(),&#10;            category=news_item.category or &quot;general&quot;,&#10;            media=media_list,&#10;            reading_time=news_item.reading_time,&#10;            views_count=news_item.views_count,&#10;            author=news_item.author,&#10;            source_name=source.name if source else None,&#10;            source_url=source.url if source else None&#10;        )&#10;&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении новости {news_id}: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Ошибка при получении новости: {str(e)}&quot;)&#10;&#10;&#10;@router.get(&quot;/categories/&quot;)&#10;async def get_categories(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить список доступных категорий&quot;&quot;&quot;&#10;    try:&#10;        categories = db.query(NewsItem.category).distinct().all()&#10;        return {&quot;categories&quot;: [cat[0] for cat in categories if cat[0]]}&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении категорий: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Ошибка при получении категорий&quot;)&#10;&#10;&#10;@router.get(&quot;/stats/&quot;)&#10;async def get_stats(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить статистику новостей&quot;&quot;&quot;&#10;    try:&#10;        total_news = db.query(NewsItem).count()&#10;&#10;        # Статистика по категориям&#10;        categories_stats = {}&#10;        categories = db.query(NewsItem.category).distinct().all()&#10;&#10;        for cat in categories:&#10;            if cat[0]:&#10;                count = db.query(NewsItem).filter(NewsItem.category == cat[0]).count()&#10;                categories_stats[cat[0]] = count&#10;&#10;        return {&#10;            &quot;total_news&quot;: total_news,&#10;            &quot;categories&quot;: categories_stats,&#10;            &quot;last_updated&quot;: datetime.now().isoformat()&#10;        }&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении статистики: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Ошибка при получении статистики&quot;)" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException, Query&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import desc&#10;from typing import List, Optional&#10;from datetime import datetime&#10;import logging&#10;&#10;from server.db import get_db, NewsItem, NewsSource&#10;from server.models import NewsResponse, NewsItemResponse, MediaItem&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.get(&quot;/news/&quot;, response_model=NewsResponse)&#10;async def get_news(&#10;        category: Optional[str] = Query(None, description=&quot;Фильтр по категории&quot;),&#10;        limit: int = Query(50, description=&quot;Количество новостей&quot;, le=100),&#10;        offset: int = Query(0, description=&quot;Смещение для пагинации&quot;),&#10;        db: Session = Depends(get_db)&#10;):&#10;    &quot;&quot;&quot;Получить список новостей с фильтрацией&quot;&quot;&quot;&#10;    try:&#10;        logger.info(f&quot;Запрос новостей: category={category}, limit={limit}, offset={offset}&quot;)&#10;&#10;        # Базовый запрос&#10;        query = db.query(NewsItem)&#10;&#10;        # Фильтр по категории&#10;        if category and category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;&#10;        # Сортировка по дате публикации&#10;        query = query.order_by(desc(NewsItem.publish_date))&#10;&#10;        # Пагинация&#10;        total = query.count()&#10;        news_items = query.offset(offset).limit(limit).all()&#10;&#10;        logger.info(f&quot;Найдено {len(news_items)} новостей из {total} общих&quot;)&#10;&#10;        # Соберем source_id для всех новостей&#10;        source_ids = [item.source_id for item in news_items if item.source_id is not None]&#10;        sources = {}&#10;        if source_ids:&#10;            sources_list = db.query(NewsSource).filter(NewsSource.id.in_(source_ids)).all()&#10;            sources = {source.id: source for source in sources_list}&#10;&#10;        # Преобразование в response модель&#10;        news_data = []&#10;        for item in news_items:&#10;            try:&#10;                # Получаем медиа из JSON поля&#10;                media_list = []&#10;                if item.media:&#10;                    try:&#10;                        media_list = [MediaItem(**media) for media in item.media]&#10;                    except Exception as e:&#10;                        logger.warning(f&quot;Error parsing media for {item.id}: {e}&quot;)&#10;&#10;                # Получаем источник&#10;                source = sources.get(item.source_id)&#10;                source_name = source.name if source else None&#10;                source_url = source.url if source else None&#10;&#10;                news_data.append(NewsItemResponse(&#10;                    id=item.id,&#10;                    title=item.title or &quot;&quot;,&#10;                    content=item.content or &quot;&quot;,  # Plain text&#10;                    content_html=item.content_html or &quot;&quot;,  # HTML контент&#10;                    link=item.link or &quot;&quot;,&#10;                    publish_date=item.publish_date.isoformat() if item.publish_date else datetime.now().isoformat(),&#10;                    category=item.category or &quot;general&quot;,&#10;                    media=media_list,&#10;                    reading_time=item.reading_time,&#10;                    views_count=item.views_count or 0,&#10;                    author=item.author,&#10;                    source_name=source_name,&#10;                    source_url=source_url,&#10;                    source=source  # &lt;-- добавлено, чтобы поле source было заполнено&#10;                ))&#10;            except Exception as e:&#10;                logger.warning(f&quot;Ошибка при обработке новости {item.id}: {e}&quot;)&#10;                continue&#10;&#10;        return NewsResponse(&#10;            data=news_data,&#10;            total=total,&#10;            page=offset // limit + 1,&#10;            pages=(total + limit - 1) // limit&#10;        )&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении новостей: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Ошибка при получении новостей: {str(e)}&quot;)&#10;&#10;&#10;@router.get(&quot;/news/{news_id}&quot;, response_model=NewsItemResponse)&#10;async def get_news_item(&#10;        news_id: int,&#10;        db: Session = Depends(get_db)&#10;):&#10;    &quot;&quot;&quot;Получить конкретную новость по ID&quot;&quot;&quot;&#10;    try:&#10;        news_item = db.query(NewsItem).filter(NewsItem.id == news_id).first()&#10;&#10;        if not news_item:&#10;            raise HTTPException(status_code=404, detail=&quot;Новость не найдена&quot;)&#10;&#10;        # Получаем источник&#10;        source = db.query(NewsSource).get(news_item.source_id) if news_item.source_id else None&#10;&#10;        # Получаем медиа&#10;        media_list = []&#10;        if news_item.media:&#10;            try:&#10;                media_list = [MediaItem(**media) for media in news_item.media]&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error parsing media for {news_item.id}: {e}&quot;)&#10;&#10;        # Увеличиваем счетчик просмотров&#10;        if news_item.views_count is None:&#10;            news_item.views_count = 0&#10;        news_item.views_count += 1&#10;        db.commit()&#10;&#10;        return NewsItemResponse(&#10;            id=news_item.id,&#10;            title=news_item.title or &quot;&quot;,&#10;            content=news_item.content or &quot;&quot;,&#10;            content_html=news_item.content_html or &quot;&quot;,&#10;            link=news_item.link or &quot;&quot;,&#10;            publish_date=news_item.publish_date.isoformat() if news_item.publish_date else datetime.now().isoformat(),&#10;            category=news_item.category or &quot;general&quot;,&#10;            media=media_list,&#10;            reading_time=news_item.reading_time,&#10;            views_count=news_item.views_count,&#10;            author=news_item.author,&#10;            source_name=source.name if source else None,&#10;            source_url=source.url if source else None&#10;        )&#10;&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении новости {news_id}: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=f&quot;Ошибка при получении новости: {str(e)}&quot;)&#10;&#10;&#10;@router.get(&quot;/categories/&quot;)&#10;async def get_categories(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить список доступных категорий&quot;&quot;&quot;&#10;    try:&#10;        categories = db.query(NewsItem.category).distinct().all()&#10;        return {&quot;categories&quot;: [cat[0] for cat in categories if cat[0]]}&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении категорий: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Ошибка при получении категорий&quot;)&#10;&#10;&#10;@router.get(&quot;/stats/&quot;)&#10;async def get_stats(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить статистику новостей&quot;&quot;&quot;&#10;    try:&#10;        total_news = db.query(NewsItem).count()&#10;&#10;        # Статистика по категориям&#10;        categories_stats = {}&#10;        categories = db.query(NewsItem.category).distinct().all()&#10;&#10;        for cat in categories:&#10;            if cat[0]:&#10;                count = db.query(NewsItem).filter(NewsItem.category == cat[0]).count()&#10;                categories_stats[cat[0]] = count&#10;&#10;        return {&#10;            &quot;total_news&quot;: total_news,&#10;            &quot;categories&quot;: categories_stats,&#10;            &quot;last_updated&quot;: datetime.now().isoformat()&#10;        }&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при получении статистики: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Ошибка при получении статистики&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/db.py" />
              <option name="updatedContent" value="from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, Boolean&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import sessionmaker, Session&#10;from datetime import datetime&#10;import os&#10;&#10;# Получаем URL базы данных из переменных окружения&#10;DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;, &quot;postgresql://user:password@localhost:5432/giftpropaganda&quot;)&#10;&#10;# Создаем движок базы данных&#10;engine = create_engine(DATABASE_URL)&#10;&#10;# Создаем фабрику сессий&#10;SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;&#10;# Базовый класс для моделей&#10;Base = declarative_base()&#10;&#10;class NewsSource(Base):&#10;    &quot;&quot;&quot;Модель источника новостей&quot;&quot;&quot;&#10;    __tablename__ = &quot;news_sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    url = Column(String(1000), nullable=False)&#10;    source_type = Column(String(50), nullable=False)  # 'telegram' или 'rss'&#10;    category = Column(String(100))&#10;    is_active = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;&#10;class NewsItem(Base):&#10;    &quot;&quot;&quot;Модель новости&quot;&quot;&quot;&#10;    __tablename__ = &quot;news_items&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(String(255), nullable=False)  # ID поста в источнике&#10;    title = Column(String(1000), nullable=False)&#10;    content = Column(Text, nullable=False)&#10;    link = Column(String(1000), nullable=False)&#10;    publish_date = Column(DateTime, nullable=False)&#10;    category = Column(String(100), nullable=False)&#10;    &#10;    # Новые поля для медиа&#10;    image_url = Column(String(1000), nullable=True)&#10;    video_url = Column(String(1000), nullable=True)&#10;    reading_time = Column(Integer, nullable=True)  # в минутах&#10;    views_count = Column(Integer, default=0)&#10;    author = Column(String(200), nullable=True)&#10;    subtitle = Column(String(500), nullable=True)&#10;    &#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)&#10;&#10;# Функция для получения сессии базы данных&#10;def get_db() -&gt; Session:&#10;    &quot;&quot;&quot;Получить сессию базы данных для FastAPI Depends&quot;&quot;&quot;&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;# Функция для создания таблиц&#10;def create_tables():&#10;    &quot;&quot;&quot;Создать все таблицы в базе данных&quot;&quot;&quot;&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Функция для получения сессии (синхронная версия)&#10;def get_db_session():&#10;    &quot;&quot;&quot;Получить сессию базы данных (синхронная версия)&quot;&quot;&quot;&#10;    return SessionLocal()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/main.py" />
              <option name="originalContent" value="import os&#10;import asyncio&#10;import logging&#10;from contextlib import asynccontextmanager&#10;from fastapi import FastAPI&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;import time&#10;from server.db import Base, NewsItem, NewsSource&#10;from server.parsers.telegram_news_service import TelegramNewsService&#10;from server.config import TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;# Глобальные переменные для БД&#10;engine = None&#10;SessionLocal = None&#10;&#10;def init_db():&#10;    &quot;&quot;&quot;Инициализация базы данных с повторными попытками&quot;&quot;&quot;&#10;    global engine, SessionLocal&#10;&#10;    # Проверяем переменные окружения&#10;    database_url = os.getenv('DATABASE_URL', 'postgresql://user:password@db:5432/giftpropaganda')&#10;    token = os.getenv('TOKEN')&#10;    webhook_url = os.getenv('WEBHOOK_URL')&#10;&#10;    # Обрезаем DATABASE_URL для логирования (убираем пароль)&#10;    safe_db_url = database_url.replace('password', '***') if 'password' in database_url else database_url&#10;    logger.info(f&quot;DATABASE_URL: {safe_db_url}&quot;)&#10;    logger.info(f&quot;TOKEN: {'SET' if token else 'NOT SET'}&quot;)&#10;    logger.info(f&quot;WEBHOOK_URL: {webhook_url}&quot;)&#10;&#10;    max_attempts = 10&#10;    for attempt in range(1, max_attempts + 1):&#10;        try:&#10;            engine = create_engine(database_url)&#10;&#10;            # Проверяем подключение&#10;            with engine.connect() as connection:&#10;                logger.info(&quot;Успешное подключение к базе данных&quot;)&#10;&#10;            # Создаем таблицы&#10;            Base.metadata.create_all(bind=engine)&#10;&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;&#10;        except Exception as e:&#10;            logger.warning(f&quot;Попытка {attempt}/{max_attempts} подключения к базе: {e}&quot;)&#10;            if attempt &lt; max_attempts:&#10;                time.sleep(5)&#10;            continue&#10;&#10;    raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def apply_migrations():&#10;    &quot;&quot;&quot;Применяет миграции базы данных&quot;&quot;&quot;&#10;    try:&#10;        global engine&#10;        logger.info(&quot;Проверка и применение миграций...&quot;)&#10;&#10;        with engine.connect() as connection:&#10;            # Проверяем, существуют ли новые поля&#10;            result = connection.execute(text(&quot;&quot;&quot;&#10;                SELECT column_name &#10;                FROM information_schema.columns &#10;                WHERE table_name = 'news_items' &#10;                AND column_name IN ('image_url', 'video_url', 'reading_time', 'views_count', 'author', 'subtitle')&#10;            &quot;&quot;&quot;))&#10;&#10;            existing_columns = [row[0] for row in result.fetchall()]&#10;            logger.info(f&quot;Существующие новые поля: {existing_columns}&quot;)&#10;&#10;            # Добавляем поля, которых еще нет&#10;            fields_to_add = [&#10;                ('image_url', 'VARCHAR(1000)'),&#10;                ('video_url', 'VARCHAR(1000)'),&#10;                ('reading_time', 'INTEGER'),&#10;                ('views_count', 'INTEGER'),&#10;                ('author', 'VARCHAR(200)'),&#10;                ('subtitle', 'VARCHAR(500)')&#10;            ]&#10;&#10;            for field_name, field_type in fields_to_add:&#10;                if field_name not in existing_columns:&#10;                    logger.info(f&quot;Добавляем поле {field_name}...&quot;)&#10;                    connection.execute(text(f&quot;&quot;&quot;&#10;                        ALTER TABLE news_items &#10;                        ADD COLUMN {field_name} {field_type}&#10;                    &quot;&quot;&quot;))&#10;                    connection.commit()&#10;                    logger.info(f&quot;Поле {field_name} добавлено успешно&quot;)&#10;                else:&#10;                    logger.info(f&quot;Поле {field_name} уже существует&quot;)&#10;&#10;            logger.info(&quot;Миграции применены успешно!&quot;)&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при применении миграций: {e}&quot;)&#10;        # Не прерываем запуск приложения из-за ошибки миграции&#10;        pass&#10;&#10;@asynccontextmanager&#10;async def lifespan(app: FastAPI):&#10;    logger.info(&quot;Запуск приложения...&quot;)&#10;&#10;    # Инициализация базы данных&#10;    init_db()&#10;&#10;    # Применение миграций&#10;    apply_migrations()&#10;&#10;    # Настройка webhook&#10;    try:&#10;        import requests&#10;        webhook_response = requests.post(&#10;            f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;,&#10;            json={&quot;url&quot;: f&quot;{WEBHOOK_URL}/webhook&quot;}&#10;        )&#10;        if webhook_response.status_code == 200:&#10;            logger.info(&quot;Webhook установлен успешно&quot;)&#10;        else:&#10;            logger.warning(f&quot;Ошибка установки webhook: {webhook_response.text}&quot;)&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при установке webhook: {e}&quot;)&#10;&#10;    # Запуск периодических задач&#10;    news_service = TelegramNewsService()&#10;&#10;    async def periodic_update():&#10;        while True:&#10;            try:&#10;                await news_service.update_news_async()&#10;                logger.info(&quot;Периодическое обновление завершено&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Ошибка при обновлении новостей: {e}&quot;)&#10;            await asyncio.sleep(3600)  # обновляем каждый час&#10;&#10;    asyncio.create_task(periodic_update())&#10;&#10;    yield&#10;&#10;    # Shutdown&#10;    logger.info(&quot;Приложение завершает работу&quot;)&#10;&#10;# Создаем FastAPI приложение&#10;app = FastAPI(&#10;    title=&quot;Gift Propaganda News API&quot;,&#10;    description=&quot;API для агрегации новостей Telegram&quot;,&#10;    version=&quot;1.0.0&quot;,&#10;    lifespan=lifespan&#10;)&#10;&#10;# Настройка CORS&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&quot;*&quot;],  # В продакшене указать конкретные домены&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Импортируем роутеры после создания app&#10;from server.api.news import router as news_router&#10;&#10;app.include_router(news_router, prefix=&quot;/api&quot;)&#10;&#10;@app.get(&quot;/&quot;)&#10;async def root():&#10;    return {&quot;message&quot;: &quot;Gift Propaganda News API&quot;, &quot;status&quot;: &quot;running&quot;}&#10;&#10;@app.get(&quot;/health&quot;)&#10;async def health():&#10;    try:&#10;        # Проверяем подключение к БД&#10;        with engine.connect() as connection:&#10;            return {&quot;status&quot;: &quot;healthy&quot;, &quot;database&quot;: &quot;connected&quot;}&#10;    except Exception as e:&#10;        return {&quot;status&quot;: &quot;unhealthy&quot;, &quot;error&quot;: str(e)}&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
              <option name="updatedContent" value="import os&#10;import asyncio&#10;import logging&#10;from contextlib import asynccontextmanager&#10;from fastapi import FastAPI&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;import time&#10;&#10;# Исправленные импорты&#10;from server.db import Base, NewsItem, NewsSource, engine, SessionLocal, create_tables&#10;from server.parsers.telegram_news_service import TelegramNewsService&#10;from server.config import TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;def init_db():&#10;    &quot;&quot;&quot;Инициализация базы данных с повторными попытками&quot;&quot;&quot;&#10;    # Проверяем переменные окружения&#10;    database_url = os.getenv('DATABASE_URL', 'postgresql://user:password@db:5432/giftpropaganda')&#10;    token = os.getenv('TOKEN')&#10;    webhook_url = os.getenv('WEBHOOK_URL')&#10;&#10;    # Обрезаем DATABASE_URL для логирования (убираем пароль)&#10;    safe_db_url = database_url.replace('password', '***') if 'password' in database_url else database_url&#10;    logger.info(f&quot;DATABASE_URL: {safe_db_url}&quot;)&#10;    logger.info(f&quot;TOKEN: {'SET' if token else 'NOT SET'}&quot;)&#10;    logger.info(f&quot;WEBHOOK_URL: {webhook_url}&quot;)&#10;&#10;    max_attempts = 10&#10;    for attempt in range(1, max_attempts + 1):&#10;        try:&#10;            # Проверяем подключение&#10;            with engine.connect() as connection:&#10;                logger.info(&quot;Успешное подключение к базе данных&quot;)&#10;&#10;            # Создаем таблицы&#10;            create_tables()&#10;&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return&#10;&#10;        except Exception as e:&#10;            logger.warning(f&quot;Попытка {attempt}/{max_attempts} подключения к базе: {e}&quot;)&#10;            if attempt &lt; max_attempts:&#10;                time.sleep(5)&#10;            continue&#10;&#10;    raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def apply_migrations():&#10;    &quot;&quot;&quot;Применяет миграции базы данных&quot;&quot;&quot;&#10;    try:&#10;        logger.info(&quot;Проверка и применение миграций...&quot;)&#10;        &#10;        with engine.connect() as connection:&#10;            # Проверяем, существуют ли новые поля&#10;            result = connection.execute(text(&quot;&quot;&quot;&#10;                SELECT column_name &#10;                FROM information_schema.columns &#10;                WHERE table_name = 'news_items' &#10;                AND column_name IN ('image_url', 'video_url', 'reading_time', 'views_count', 'author', 'subtitle')&#10;            &quot;&quot;&quot;))&#10;            &#10;            existing_columns = [row[0] for row in result.fetchall()]&#10;            logger.info(f&quot;Существующие новые поля: {existing_columns}&quot;)&#10;            &#10;            # Добавляем поля, которых еще нет&#10;            fields_to_add = [&#10;                ('image_url', 'VARCHAR(1000)'),&#10;                ('video_url', 'VARCHAR(1000)'),&#10;                ('reading_time', 'INTEGER'),&#10;                ('views_count', 'INTEGER'),&#10;                ('author', 'VARCHAR(200)'),&#10;                ('subtitle', 'VARCHAR(500)')&#10;            ]&#10;            &#10;            for field_name, field_type in fields_to_add:&#10;                if field_name not in existing_columns:&#10;                    logger.info(f&quot;Добавляем поле {field_name}...&quot;)&#10;                    connection.execute(text(f&quot;&quot;&quot;&#10;                        ALTER TABLE news_items &#10;                        ADD COLUMN {field_name} {field_type}&#10;                    &quot;&quot;&quot;))&#10;                    connection.commit()&#10;                    logger.info(f&quot;Поле {field_name} добавлено успешно&quot;)&#10;                else:&#10;                    logger.info(f&quot;Поле {field_name} уже существует&quot;)&#10;            &#10;            logger.info(&quot;Миграции применены успешно!&quot;)&#10;            &#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при применении миграций: {e}&quot;)&#10;        # Не прерываем запуск приложения из-за ошибки миграции&#10;        pass&#10;&#10;@asynccontextmanager&#10;async def lifespan(app: FastAPI):&#10;    logger.info(&quot;Запуск приложения...&quot;)&#10;    &#10;    # Инициализация базы данных&#10;    init_db()&#10;    &#10;    # Применение миграций&#10;    apply_migrations()&#10;&#10;    # Настройка webhook&#10;    try:&#10;        import requests&#10;        webhook_response = requests.post(&#10;            f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;,&#10;            json={&quot;url&quot;: f&quot;{WEBHOOK_URL}/webhook&quot;}&#10;        )&#10;        if webhook_response.status_code == 200:&#10;            logger.info(&quot;Webhook установлен успешно&quot;)&#10;        else:&#10;            logger.warning(f&quot;Ошибка установки webhook: {webhook_response.text}&quot;)&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при установке webhook: {e}&quot;)&#10;&#10;    # Запуск периодических задач&#10;    news_service = TelegramNewsService()&#10;&#10;    async def periodic_update():&#10;        while True:&#10;            try:&#10;                await news_service.update_news_async()&#10;                logger.info(&quot;Периодическое обновление завершено&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Ошибка при обновлении новостей: {e}&quot;)&#10;            await asyncio.sleep(3600)  # обновляем каждый час&#10;&#10;    asyncio.create_task(periodic_update())&#10;&#10;    yield&#10;&#10;    # Shutdown&#10;    logger.info(&quot;Приложение завершает работу&quot;)&#10;&#10;# Создаем FastAPI приложение&#10;app = FastAPI(&#10;    title=&quot;Gift Propaganda News API&quot;,&#10;    description=&quot;API для агрегации новостей Telegram&quot;,&#10;    version=&quot;1.0.0&quot;,&#10;    lifespan=lifespan&#10;)&#10;&#10;# Настройка CORS&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&quot;*&quot;],  # В продакшене указать конкретные домены&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Импортируем роутеры после создания app&#10;from server.api.news import router as news_router&#10;&#10;app.include_router(news_router, prefix=&quot;/api&quot;)&#10;&#10;@app.get(&quot;/&quot;)&#10;async def root():&#10;    return {&quot;message&quot;: &quot;Gift Propaganda News API&quot;, &quot;status&quot;: &quot;running&quot;}&#10;&#10;@app.get(&quot;/health&quot;)&#10;async def health():&#10;    try:&#10;        # Проверяем подключение к БД&#10;        with engine.connect() as connection:&#10;            return {&quot;status&quot;: &quot;healthy&quot;, &quot;database&quot;: &quot;connected&quot;}&#10;    except Exception as e:&#10;        return {&quot;status&quot;: &quot;unhealthy&quot;, &quot;error&quot;: str(e)}&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models.py" />
              <option name="updatedContent" value="from pydantic import BaseModel&#10;from typing import List, Optional&#10;from datetime import datetime&#10;&#10;class NewsItemResponse(BaseModel):&#10;    id: int&#10;    title: str&#10;    content: str&#10;    link: str&#10;    publish_date: str&#10;    category: str&#10;    image_url: Optional[str] = None&#10;    video_url: Optional[str] = None&#10;    reading_time: Optional[int] = None&#10;    views_count: Optional[int] = 0&#10;    author: Optional[str] = None&#10;    subtitle: Optional[str] = None&#10;&#10;    class Config:&#10;        from_attributes = True&#10;&#10;class NewsResponse(BaseModel):&#10;    data: List[NewsItemResponse]&#10;    total: int&#10;    page: int&#10;    pages: int&#10;&#10;class CategoryResponse(BaseModel):&#10;    categories: List[str]&#10;&#10;class StatsResponse(BaseModel):&#10;    total_news: int&#10;    categories: dict&#10;    last_updated: str" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/rss.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/rss.py" />
              <option name="updatedContent" value="import feedparser&#10;import logging&#10;from sqlalchemy.orm import Session&#10;from typing import List, Dict, Any&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;async def fetch_rss_feeds(session: Session) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Получение новостей из RSS источников&quot;&quot;&quot;&#10;    try:&#10;        logger.info(&quot;Fetching RSS feeds...&quot;)&#10;        &#10;        # Список RSS источников&#10;        rss_sources = [&#10;            {&quot;url&quot;: &quot;https://vc.ru/rss&quot;, &quot;name&quot;: &quot;VC.ru&quot;, &quot;category&quot;: &quot;tech&quot;},&#10;            {&quot;url&quot;: &quot;https://forklog.com/feed/&quot;, &quot;name&quot;: &quot;ForkLog&quot;, &quot;category&quot;: &quot;crypto&quot;}&#10;        ]&#10;        &#10;        articles = []&#10;        for source in rss_sources:&#10;            try:&#10;                feed = feedparser.parse(source[&quot;url&quot;])&#10;                for entry in feed.entries[:5]:  # Берем только 5 последних&#10;                    article = {&#10;                        &quot;title&quot;: entry.title,&#10;                        &quot;link&quot;: entry.link,&#10;                        &quot;description&quot;: getattr(entry, 'summary', ''),&#10;                        &quot;source&quot;: source[&quot;name&quot;],&#10;                        &quot;category&quot;: source[&quot;category&quot;]&#10;                    }&#10;                    articles.append(article)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error parsing RSS {source['url']}: {e}&quot;)&#10;        &#10;        logger.info(f&quot;RSS feeds fetched successfully, {len(articles)} articles&quot;)&#10;        return articles&#10;        &#10;    except Exception as e:&#10;        logger.error(f&quot;Error fetching RSS feeds: {e}&quot;)&#10;        return []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/telegram_news_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/telegram_news_service.py" />
              <option name="originalContent" value="import aiohttp&#10;import asyncio&#10;import feedparser&#10;from typing import List, Dict, Any, Optional&#10;import json&#10;from datetime import datetime, timedelta&#10;import logging&#10;import re&#10;import hashlib&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class TelegramNewsService:&#10;    &quot;&quot;&quot;Сервис для получения новостей из Telegram каналов и RSS источников&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Telegram каналы согласно ТЗ - ключевые источники по темам подарков, NFT и крипто&#10;        self.channels = [&#10;            # Каналы о подарках и бонусах&#10;            {'username': 'gift_newstg', 'name': 'Gift News TG', 'category': 'gifts'},&#10;            {'username': 'giftsutya', 'name': 'Gift Sutya', 'category': 'gifts'},&#10;            {'username': 'diruil_gifts', 'name': 'Diruil Gifts', 'category': 'gifts'},&#10;            {'username': 'giftnews', 'name': 'Gift News', 'category': 'gifts'},&#10;            {'username': 'BunnyStarsShop', 'name': 'Bunny Stars Shop', 'category': 'gifts'},&#10;            {'username': 'nft_podarki', 'name': 'NFT Подарки', 'category': 'gifts'},&#10;&#10;            # Технологии и инновации&#10;            {'username': 'westik', 'name': 'Westik', 'category': 'tech'},&#10;&#10;            # Сообщества и чаты&#10;            {'username': 'OHUENKOchat', 'name': 'OHUENKO Chat', 'category': 'community'},&#10;            {'username': 'community', 'name': 'Community', 'category': 'community'},&#10;            {'username': 'groza', 'name': 'Groza', 'category': 'community'},&#10;&#10;            # Криптовалюты и блокчейн&#10;            {'username': 'omicron', 'name': 'Omicron', 'category': 'crypto'},&#10;            {'username': 'tontopic_1', 'name': 'TON Topic', 'category': 'crypto'},&#10;            {'username': 'procryptodoping', 'name': 'Pro Crypto Doping', 'category': 'crypto'},&#10;&#10;            # NFT и цифровое искусство&#10;            {'username': 'nextgen_NFT', 'name': 'NextGen NFT', 'category': 'nft'},&#10;            {'username': 'snoopdogg', 'name': 'Snoop Dogg', 'category': 'nft'}&#10;        ]&#10;&#10;        # RSS источники согласно ТЗ - до 5 проверенных лент&#10;        self.rss_sources = [&#10;            {'url': 'https://vc.ru/rss', 'name': 'VC.ru', 'category': 'tech'},&#10;            {'url': 'https://forklog.com/feed/', 'name': 'ForkLog', 'category': 'crypto'},&#10;            {'url': 'https://www.coindesk.com/arc/outboundfeeds/rss/', 'name': 'CoinDesk', 'category': 'crypto'},&#10;            {'url': 'https://cointelegraph.com/rss', 'name': 'Cointelegraph', 'category': 'crypto'},&#10;            {'url': 'https://habr.com/ru/rss/articles/', 'name': 'Habr NFT', 'category': 'nft'}&#10;        ]&#10;&#10;        self.cache = {}&#10;        self.cache_ttl = timedelta(minutes=30)  # Кэш на 30 минут согласно ТЗ&#10;&#10;        # Ключевые слова для категоризации согласно ТЗ&#10;        self.keywords = {&#10;            'gifts': [&#10;                'подарок', 'подарки', 'бесплатно', 'халява', 'промокод', 'скидка',&#10;                'акция', 'розыгрыш', 'бонус', 'даром', 'гифт', 'gift', 'freebie',&#10;                'раздача', 'конкурс', 'приз', 'награда', 'cashback', 'кэшбек'&#10;            ],&#10;            'nft': [&#10;                'nft', 'нфт', 'токен', 'коллекция', 'мета', 'opensea', 'digital art',&#10;                'коллекционный', 'цифровое искусство', 'метавселенная', 'avatar',&#10;                'аватар', 'pfp', 'mint', 'минт', 'drop', 'дроп', 'rare', 'раритет'&#10;            ],&#10;            'crypto': [&#10;                'криптовалюта', 'биткоин', 'bitcoin', 'ethereum', 'блокчейн', 'деф',&#10;                'defi', 'торги', 'курс', 'btc', 'eth', 'usdt', 'binance', 'трейдинг',&#10;                'стейкинг', 'майнинг', 'altcoin', 'альткоин', 'pump', 'dump', 'hodl'&#10;            ],&#10;            'tech': [&#10;                'технологии', 'it', 'ит', 'программирование', 'разработка', 'стартап',&#10;                'инновации', 'ai', 'ии', 'machine learning', 'блокчейн', 'веб3',&#10;                'app', 'приложение', 'software', 'hardware', 'gadget', 'гаджет'&#10;            ],&#10;            'community': [&#10;                'сообщество', 'чат', 'общение', 'форум', 'дискуссия', 'мнение',&#10;                'обсуждение', 'новости', 'анонс', 'встреча', 'event', 'мероприятие'&#10;            ]&#10;        }&#10;&#10;    def categorize_content(self, title: str, description: str = &quot;&quot;) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Автоматическая категоризация контента по ключевым словам согласно ТЗ&#10;        Приоритет: gifts &gt; crypto &gt; nft &gt; tech &gt; community&#10;        &quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        # Подсчитываем совпадения для каждой категории&#10;        category_scores = {}&#10;        for category, keywords in self.keywords.items():&#10;            score = sum(1 for keyword in keywords if keyword in content)&#10;            if score &gt; 0:&#10;                category_scores[category] = score&#10;&#10;        if not category_scores:&#10;            return 'general'&#10;&#10;        # Возвращаем категорию с наибольшим количеством совпадений&#10;        # При равенстве очков используем приоритет&#10;        priority = ['gifts', 'crypto', 'nft', 'tech', 'community']&#10;&#10;        max_score = max(category_scores.values())&#10;        best_categories = [cat for cat, score in category_scores.items() if score == max_score]&#10;&#10;        for priority_cat in priority:&#10;            if priority_cat in best_categories:&#10;                return priority_cat&#10;&#10;        return list(category_scores.keys())[0]  # Fallback&#10;&#10;    async def fetch_telegram_channel(self, channel_username: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получение новостей из Telegram канала через веб-скрапинг&#10;        Согласно ТЗ - интеграция с Telegram каналами для получения актуальных новостей&#10;        &quot;&quot;&quot;&#10;        try:&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == channel_username), None)&#10;            if not channel_data:&#10;                logger.warning(f&quot;Channel {channel_username} not found in configured channels&quot;)&#10;                return []&#10;&#10;            # Используем публичный API Telegram для получения постов&#10;            url = f&quot;https://t.me/s/{channel_username}&quot;&#10;&#10;            async with aiohttp.ClientSession() as session:&#10;                try:&#10;                    async with session.get(url, timeout=10) as response:&#10;                        if response.status == 200:&#10;                            html_content = await response.text()&#10;                            return self._parse_telegram_html(html_content, channel_data)&#10;                        else:&#10;                            logger.warning(f&quot;Failed to fetch {url}, status: {response.status}&quot;)&#10;                            return self._generate_mock_posts(channel_data)&#10;                except aiohttp.ClientTimeout:&#10;                    logger.warning(f&quot;Timeout fetching {url}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;                except Exception as e:&#10;                    logger.warning(f&quot;Error fetching {url}: {e}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in fetch_telegram_channel for {channel_username}: {e}&quot;)&#10;            return []&#10;&#10;    def _parse_telegram_html(self, html_content: str, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Парсинг HTML содержимого Telegram канала с поддержкой медиа&quot;&quot;&quot;&#10;        import re&#10;        from html import unescape&#10;&#10;        posts = []&#10;&#10;        # Простой парсер для получения постов из HTML&#10;        # В реальном проекте лучше использовать BeautifulSoup&#10;        post_pattern = r'&lt;div class=&quot;tgme_widget_message.*?&lt;/div&gt;\s*&lt;/div&gt;\s*&lt;/div&gt;'&#10;        text_pattern = r'&lt;div class=&quot;tgme_widget_message_text.*?&quot;.*?&gt;(.*?)&lt;/div&gt;'&#10;        date_pattern = r'&lt;time.*?datetime=&quot;([^&quot;]+)&quot;'&#10;&#10;        # Паттерны для медиа контента&#10;        photo_pattern = r'&lt;a.*?class=&quot;tgme_widget_message_photo_wrap.*?style=&quot;background-image:url\(&amp;quot;([^&amp;]+)&amp;quot;\)&quot;'&#10;        video_pattern = r'&lt;video.*?src=&quot;([^&quot;]+)&quot;.*?poster=&quot;([^&quot;]*)&quot;.*?&gt;'&#10;        video_thumb_pattern = r'&lt;video.*?poster=&quot;([^&quot;]+)&quot;.*?&gt;'&#10;&#10;        post_matches = re.findall(post_pattern, html_content, re.DOTALL)&#10;&#10;        for i, post_html in enumerate(post_matches[:10]):  # Берем только первые 10 постов&#10;            # Извлекаем текст поста&#10;            text_match = re.search(text_pattern, post_html, re.DOTALL)&#10;            text = &quot;&quot;&#10;            if text_match:&#10;                text = unescape(re.sub(r'&lt;[^&gt;]+&gt;', '', text_match.group(1)))&#10;                text = text.strip()[:300] + &quot;...&quot; if len(text) &gt; 300 else text.strip()&#10;&#10;            # Извлекаем дату&#10;            date_match = re.search(date_pattern, post_html)&#10;            date = datetime.now().isoformat()&#10;            if date_match:&#10;                try:&#10;                    date = datetime.fromisoformat(date_match.group(1).replace('Z', '+00:00')).isoformat()&#10;                except:&#10;                    pass&#10;&#10;            # Извлекаем медиа контент&#10;            media = None&#10;&#10;            # Проверяем на фото&#10;            photo_match = re.search(photo_pattern, post_html)&#10;            if photo_match:&#10;                photo_url = photo_match.group(1).replace('&amp;amp;', '&amp;')&#10;                media = {&#10;                    'type': 'photo',&#10;                    'url': photo_url,&#10;                    'thumbnail': photo_url,  # Для фото thumbnail = основное изображение&#10;                    'width': None,&#10;                    'height': None&#10;                }&#10;&#10;            # Проверяем на видео&#10;            video_match = re.search(video_pattern, post_html)&#10;            if video_match:&#10;                video_url = video_match.group(1)&#10;                thumbnail_url = video_match.group(2) if len(video_match.groups()) &gt; 1 else None&#10;                media = {&#10;                    'type': 'video',&#10;                    'url': video_url,&#10;                    'thumbnail': thumbnail_url,&#10;                    'width': None,&#10;                    'height': None&#10;                }&#10;            elif not media:  # Если не нашли полное видео, ищем только thumbnail&#10;                video_thumb_match = re.search(video_thumb_pattern, post_html)&#10;                if video_thumb_match:&#10;                    media = {&#10;                        'type': 'video',&#10;                        'url': None,  # URL видео не найден&#10;                        'thumbnail': video_thumb_match.group(1),&#10;                        'width': None,&#10;                        'height': None&#10;                    }&#10;&#10;            if text:  # Только если удалось извлечь текст&#10;                # Генерируем заголовок из первых слов&#10;                title = text.split('.')[0][:100] if text else f&quot;Пост от {channel_data['name']}&quot;&#10;&#10;                post = {&#10;                    'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text[:50]}&quot;.encode()).hexdigest(),&#10;                    'title': title,&#10;                    'text': text,&#10;                    'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                    'date': date,&#10;                    'source': channel_data['name'],&#10;                    'category': channel_data['category'],&#10;                    'channel': channel_data['username'],&#10;                    'media': media  # Добавляем медиа данные&#10;                }&#10;&#10;                posts.append(post)&#10;&#10;        if not posts:  # Если парсинг не удался, используем мок данные&#10;            return self._generate_mock_posts(channel_data)&#10;&#10;        return posts&#10;&#10;    def _generate_mock_posts(self, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Генерация мок данных для канала согласно ТЗ&quot;&quot;&quot;&#10;        posts = []&#10;        base_time = datetime.now()&#10;&#10;        # Контент в зависимости от категории канала&#10;        content_templates = {&#10;            'gifts': [&#10;                &quot; Новые бесплатные подарки! Успейте получить эксклюзивные бонусы&quot;,&#10;                &quot; Промокоды на скидки до 70%! Ограниченное предложение&quot;,&#10;                &quot; Розыгрыш ценных призов среди подписчиков канала&quot;,&#10;                &quot;️ Лучшие предложения дня - не пропустите!&quot;&#10;            ],&#10;            'crypto': [&#10;                &quot; Анализ рынка: Bitcoin показывает рост на 5%&quot;,&#10;                &quot; Новые возможности DeFi инвестиций - обзор проектов&quot;,&#10;                &quot; Перспективные альткоины для долгосрочных инвестиций&quot;,&#10;                &quot;⚡ Срочные новости: крупные движения на криптовалютном рынке&quot;&#10;            ],&#10;            'nft': [&#10;                &quot;️ Новая коллекция NFT от известного художника уже в продаже&quot;,&#10;                &quot; Раритетные токены на аукционе - последний шанс приобрести&quot;,&#10;                &quot; Обзор лучших NFT художников недели&quot;,&#10;                &quot; Статистика NFT рынка: рост объемов торгов на 15%&quot;&#10;            ],&#10;            'tech': [&#10;                &quot; Революционные технологии 2025 года - что нас ждет&quot;,&#10;                &quot; Обзор новейших гаджетов от мировых производителей&quot;,&#10;                &quot; Стартапы в сфере ИИ привлекли рекордные инвестиции&quot;,&#10;                &quot; ТОП мобильных приложений для повышения продуктивности&quot;&#10;            ],&#10;            'community': [&#10;                &quot; Обсуждение актуальных тем в нашем сообществе&quot;,&#10;                &quot; Важные новости и обновления для участников&quot;,&#10;                &quot; Анонс предстоящих мероприятий и встреч&quot;,&#10;                &quot; Полезные советы и рекомендации от экспертов&quot;&#10;            ]&#10;        }&#10;&#10;        templates = content_templates.get(channel_data['category'], content_templates['community'])&#10;&#10;        for i in range(5):  # Генерируем 5 постов&#10;            post_time = base_time - timedelta(hours=i * 4 + hash(channel_data['username']) % 12)&#10;&#10;            text = templates[i % len(templates)]&#10;            title = text.split('.')[0][:80] + (&quot;...&quot; if len(text.split('.')[0]) &gt; 80 else &quot;&quot;)&#10;&#10;            posts.append({&#10;                'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text}&quot;.encode()).hexdigest(),&#10;                'title': title,&#10;                'text': text,&#10;                'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                'date': post_time.isoformat(),&#10;                'source': channel_data['name'],&#10;                'category': channel_data['category'],&#10;                'channel': channel_data['username']&#10;            })&#10;&#10;        return posts&#10;        &quot;&quot;&quot;Автоматическая категоризация контента по ключевым словам&quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        for category, keywords in self.keywords.items():&#10;            if any(keyword in content for keyword in keywords):&#10;                return category&#10;&#10;        return 'general'&#10;&#10;    async def fetch_rss_feed(self, source: Dict[str, str]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получение новостей из RSS источника&quot;&quot;&quot;&#10;        try:&#10;            # Используем feedparser для парсинга RSS&#10;            feed = feedparser.parse(source['url'])&#10;&#10;            if not feed.entries:&#10;                logger.warning(f&quot;No entries found in RSS feed: {source['url']}&quot;)&#10;                return []&#10;&#10;            articles = []&#10;            for entry in feed.entries[:10]:  # Берем только последние 10 новостей&#10;                # Получаем описание из различных полей&#10;                description = &quot;&quot;&#10;                if hasattr(entry, 'summary'):&#10;                    description = entry.summary&#10;                elif hasattr(entry, 'description'):&#10;                    description = entry.description&#10;                elif hasattr(entry, 'content'):&#10;                    description = entry.content[0].value if entry.content else &quot;&quot;&#10;&#10;                # Очищаем HTML теги&#10;                clean_description = re.sub(r'&lt;[^&gt;]+&gt;', '', description)&#10;                clean_description = clean_description[:200] + &quot;...&quot; if len(&#10;                    clean_description) &gt; 200 else clean_description&#10;&#10;                # Получаем дату публикации&#10;                pub_date = datetime.now()&#10;                if hasattr(entry, 'published_parsed') and entry.published_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.published_parsed))&#10;                elif hasattr(entry, 'updated_parsed') and entry.updated_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.updated_parsed))&#10;&#10;                # Автоматическая категоризация&#10;                auto_category = self.categorize_content(entry.title, clean_description)&#10;                final_category = source.get('category', auto_category)&#10;&#10;                # Извлекаем медиа контент&#10;                media = None&#10;&#10;                # Проверяем enclosures (вложения)&#10;                if hasattr(entry, 'enclosures') and entry.enclosures:&#10;                    for enclosure in entry.enclosures:&#10;                        if hasattr(enclosure, 'type'):&#10;                            if enclosure.type.startswith('image/'):&#10;                                media = {&#10;                                    'type': 'photo',&#10;                                    'url': enclosure.href,&#10;                                    'thumbnail': enclosure.href&#10;                                }&#10;                                break&#10;                            elif enclosure.type.startswith('video/'):&#10;                                media = {&#10;                                    'type': 'video',&#10;                                    'url': enclosure.href,&#10;                                    'thumbnail': None&#10;                                }&#10;                                break&#10;&#10;                # Проверяем media:content (альтернативный способ)&#10;                if not media and hasattr(entry, 'media_content') and entry.media_content:&#10;                    for media_item in entry.media_content:&#10;                        if media_item.get('type', '').startswith('image/'):&#10;                            media = {&#10;                                'type': 'photo',&#10;                                'url': media_item.get('url', ''),&#10;                                'thumbnail': media_item.get('url', '')&#10;                            }&#10;                            break&#10;&#10;                # Формируем HTML контент&#10;                content_html = clean_description&#10;                if media:&#10;                    if media.get('type') == 'photo' and media.get('url'):&#10;                        content_html += f'&lt;img src=&quot;{media[&quot;url&quot;]}&quot; style=&quot;max-width:100%&quot;/&gt;'&#10;                    elif media.get('type') == 'video' and media.get('url'):&#10;                        thumbnail = media.get('thumbnail', '')&#10;                        content_html += f'&lt;video controls poster=&quot;{thumbnail}&quot; style=&quot;max-width:100%&quot;&gt;'&#10;                        content_html += f'&lt;source src=&quot;{media[&quot;url&quot;]}&quot; type=&quot;video/mp4&quot;&gt;'&#10;                        content_html += '&lt;/video&gt;'&#10;&#10;                article = {&#10;                    'id': hashlib.md5((entry.link + entry.title).encode()).hexdigest(),&#10;                    'title': entry.title,&#10;                    'text': clean_description,  # Plain text&#10;                    'content_html': content_html,  # HTML с медиа&#10;                    'link': entry.link,&#10;                    'date': pub_date.isoformat(),&#10;                    'source': source['name'],&#10;                    'category': final_category,&#10;                    'channel': 'rss_' + source['name'].lower().replace(' ', '_'),&#10;                    'media': [media] if media else None&#10;                }&#10;&#10;                articles.append(article)&#10;&#10;            return articles&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching RSS feed {source['url']}: {e}&quot;)&#10;            return []&#10;        &quot;&quot;&quot;Получить информацию о канале через Telegram API&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока возвращаем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return None&#10;&#10;            return {&#10;                'username': username,&#10;                'title': channel_data['name'],&#10;                'description': f&quot;Канал {channel_data['name']} - {channel_data['category']}&quot;,&#10;                'subscribers_count': 1000 + hash(username) % 50000,  # Мок количества подписчиков&#10;                'category': channel_data['category']&#10;            }&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channel info for {username}: {e}&quot;)&#10;            return None&#10;&#10;    async def get_channel_posts(self, username: str, limit: int = 10) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить последние посты из канала&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока генерируем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return []&#10;&#10;            posts = []&#10;            base_time = datetime.now()&#10;&#10;            for i in range(limit):&#10;                post_time = base_time - timedelta(hours=i * 2 + hash(username + str(i)) % 24)&#10;&#10;                # Генерируем контент на основе категории&#10;                if channel_data['category'] == 'gifts':&#10;                    titles = [&#10;                        f&quot; Новые бесплатные подарки в {channel_data['name']}!&quot;,&#10;                        f&quot; Эксклюзивные промокоды и скидки&quot;,&#10;                        f&quot; Розыгрыш призов для подписчиков&quot;,&#10;                        f&quot;️ Лучшие предложения дня&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'crypto':&#10;                    titles = [&#10;                        f&quot; Анализ рынка криптовалют&quot;,&#10;                        f&quot; Новые возможности для инвестиций&quot;,&#10;                        f&quot; Обзор перспективных проектов&quot;,&#10;                        f&quot;⚡ Быстрые новости из мира крипто&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'nft':&#10;                    titles = [&#10;                        f&quot;️ Новые NFT коллекции&quot;,&#10;                        f&quot; Раритетные токены на аукционе&quot;,&#10;                        f&quot; Обзор NFT художников&quot;,&#10;                        f&quot; Статистика NFT рынка&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'tech':&#10;                    titles = [&#10;                        f&quot; Новости технологий&quot;,&#10;                        f&quot; Обзор гаджетов&quot;,&#10;                        f&quot; Инновации в IT&quot;,&#10;                        f&quot; Мобильные приложения&quot;&#10;                    ]&#10;                else:&#10;                    titles = [&#10;                        f&quot; Новости от {channel_data['name']}&quot;,&#10;                        f&quot;ℹ️ Важные обновления&quot;,&#10;                        f&quot; Полезная информация&quot;,&#10;                        f&quot; Горячие темы&quot;&#10;                    ]&#10;&#10;                title = titles[i % len(titles)]&#10;&#10;                posts.append({&#10;                    'id': f&quot;{username}_{i}&quot;,&#10;                    'title': title,&#10;                    'text': f&quot;Интересный контент от канала {channel_data['name']}. Подписывайтесь для получения актуальных новостей!&quot;,&#10;                    'date': post_time.isoformat(),&#10;                    'views': 100 + hash(username + str(i)) % 5000,&#10;                    'link': f&quot;https://t.me/{username}&quot;,&#10;                    'channel': username,&#10;                    'category': channel_data['category']&#10;                })&#10;&#10;            return posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting posts for {username}: {e}&quot;)&#10;            return []&#10;&#10;    async def get_all_news(self, category: str = 'all', limit: int = 50) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получить новости из всех источников согласно ТЗ:&#10;        - Telegram каналы (основные источники)&#10;        - RSS ленты (дополнительные источники)&#10;        - Автоматическая категоризация и дедупликация&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Проверяем кэш&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, cached_time = self.cache[cache_key]&#10;                if datetime.now() - cached_time &lt; self.cache_ttl:&#10;                    logger.info(f&quot;Returning cached news for {category}, {len(cached_data)} items&quot;)&#10;                    return cached_data&#10;&#10;            all_posts = []&#10;&#10;            # 1. Получаем данные из Telegram каналов (приоритетный источник согласно ТЗ)&#10;            telegram_channels = self.channels&#10;            if category != 'all':&#10;                telegram_channels = [ch for ch in self.channels if ch['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(telegram_channels)} Telegram channels&quot;)&#10;&#10;            # Получаем посты из Telegram каналов&#10;            telegram_tasks = []&#10;            for channel in telegram_channels:&#10;                telegram_tasks.append(self.fetch_telegram_channel(channel['username']))&#10;&#10;            telegram_results = await asyncio.gather(*telegram_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(telegram_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} posts from {telegram_channels[i]['username']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching posts from {telegram_channels[i]['username']}: {result}&quot;)&#10;&#10;            # 2. Получаем данные из RSS источников (дополнительный источник)&#10;            rss_sources = self.rss_sources&#10;            if category != 'all':&#10;                rss_sources = [src for src in self.rss_sources if src['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(rss_sources)} RSS sources&quot;)&#10;&#10;            # Получаем статьи из RSS&#10;            rss_tasks = []&#10;            for source in rss_sources:&#10;                rss_tasks.append(self.fetch_rss_feed(source))&#10;&#10;            rss_results = await asyncio.gather(*rss_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(rss_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} articles from {rss_sources[i]['name']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching RSS from {rss_sources[i]['url']}: {result}&quot;)&#10;&#10;            # 3. Обработка и дедупликация согласно ТЗ&#10;            # Удаляем дубликаты по заголовку и ссылке&#10;            seen = set()&#10;            unique_posts = []&#10;            for post in all_posts:&#10;                # Создаем ключ для дедупликации&#10;                title_clean = re.sub(r'[^\w\s]', '', post['title'].lower()).strip()&#10;                key = (title_clean, post.get('link', ''))&#10;                if key not in seen:&#10;                    seen.add(key)&#10;                    unique_posts.append(post)&#10;&#10;            logger.info(f&quot;After deduplication: {len(unique_posts)} unique posts from {len(all_posts)} total&quot;)&#10;&#10;            # 4. Сортировка по дате (новые сначала)&#10;            try:&#10;                unique_posts.sort(&#10;                    key=lambda x: datetime.fromisoformat(x['date'].replace('Z', '+00:00')),&#10;                    reverse=True&#10;                )&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error sorting by date: {e}, using original order&quot;)&#10;&#10;            # 5. Ограничиваем количество согласно ТЗ&#10;            final_posts = unique_posts[:limit]&#10;&#10;            # 6. Сохраняем в кэш на 30 минут согласно ТЗ&#10;            self.cache[cache_key] = (final_posts, datetime.now())&#10;&#10;            logger.info(f&quot;Returning {len(final_posts)} news items for category '{category}'&quot;)&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in get_all_news: {e}&quot;)&#10;            # В случае ошибки возвращаем данные из кэша, если есть&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, _ = self.cache[cache_key]&#10;                logger.info(&quot;Returning stale cached data due to error&quot;)&#10;                return cached_data&#10;            return []&#10;&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting all news: {e}&quot;)&#10;            return []&#10;&#10;    async def get_channels_info(self) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить информацию о всех каналах&quot;&quot;&quot;&#10;        try:&#10;            tasks = []&#10;            for channel in self.channels:&#10;                tasks.append(self.get_channel_info(channel['username']))&#10;&#10;            results = await asyncio.gather(*tasks, return_exceptions=True)&#10;&#10;            channels_info = []&#10;            for result in results:&#10;                if isinstance(result, dict):&#10;                    channels_info.append(result)&#10;&#10;            return channels_info&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channels info: {e}&quot;)&#10;            return []&#10;&#10;    async def update_news_async(self):&#10;        &quot;&quot;&quot;&#10;        Асинхронное обновление новостей из всех источников&#10;        Метод для периодического обновления в main.py&#10;        &quot;&quot;&quot;&#10;        try:&#10;            logger.info(f&quot;Fetching from {len(self.channels)} Telegram channels&quot;)&#10;&#10;            # Получаем новости из Telegram каналов&#10;            all_posts = []&#10;            for channel in self.channels:&#10;                try:&#10;                    posts = await self.fetch_telegram_channel(channel['username'])&#10;                    logger.info(f&quot;Got {len(posts)} posts from {channel['username']}&quot;)&#10;                    all_posts.extend(posts)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Error fetching from channel {channel['username']}: {e}&quot;)&#10;                    continue&#10;&#10;            # Получаем новости из RSS источников&#10;            logger.info(f&quot;Fetching from {len(self.rss_sources)} RSS sources&quot;)&#10;            for source in self.rss_sources:&#10;                try:&#10;                    articles = await self.fetch_rss_source(source['url'], source['name'], source['category'])&#10;                    logger.info(f&quot;Got {len(articles)} articles from {source['name']}&quot;)&#10;                    all_posts.extend(articles)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Error fetching from RSS {source['name']}: {e}&quot;)&#10;                    continue&#10;&#10;            # Дедуплицируем по заголовкам&#10;            unique_posts = []&#10;            seen_titles = set()&#10;&#10;            for post in all_posts:&#10;                title_hash = hashlib.md5(post['title'].encode()).hexdigest()&#10;                if title_hash not in seen_titles:&#10;                    seen_titles.add(title_hash)&#10;                    unique_posts.append(post)&#10;&#10;            logger.info(f&quot;After deduplication: {len(unique_posts)} unique posts from {len(all_posts)} total&quot;)&#10;&#10;            # Сортируем по дате (новые сначала)&#10;            try:&#10;                unique_posts.sort(key=lambda x: x['date'], reverse=True)&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error sorting by date: {e}, using original order&quot;)&#10;&#10;            # Сохраняем в базу данных&#10;            await self.save_to_database(unique_posts[:50])  # Сохраняем только 50 самых свежих&#10;&#10;            logger.info(f&quot;Successfully updated {len(unique_posts[:50])} news items&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in update_news_async: {e}&quot;)&#10;            raise&#10;&#10;    async def fetch_rss_source(self, url: str, name: str, category: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получение новостей из RSS источника&quot;&quot;&quot;&#10;        try:&#10;            async with aiohttp.ClientSession() as session:&#10;                async with session.get(url, timeout=10) as response:&#10;                    if response.status != 200:&#10;                        logger.warning(f&quot;Failed to fetch RSS {url}, status: {response.status}&quot;)&#10;                        return []&#10;&#10;                    content = await response.text()&#10;                    feed = feedparser.parse(content)&#10;&#10;                    if not feed.entries:&#10;                        logger.warning(f&quot;No entries found in RSS feed: {url}&quot;)&#10;                        return []&#10;&#10;                    articles = []&#10;                    for entry in feed.entries[:10]:  # Берем только 10 последних статей&#10;                        # Извлекаем основную информацию&#10;                        title = entry.get('title', 'Без заголовка')&#10;                        description = entry.get('description', '') or entry.get('summary', '')&#10;                        link = entry.get('link', '')&#10;&#10;                        # Парсим дату&#10;                        date = datetime.now().isoformat()&#10;                        if hasattr(entry, 'published_parsed') and entry.published_parsed:&#10;                            try:&#10;                                import time&#10;                                date = datetime.fromtimestamp(time.mktime(entry.published_parsed)).isoformat()&#10;                            except:&#10;                                pass&#10;&#10;                        # Извлекаем медиа контент&#10;                        media = None&#10;&#10;                        # Проверяем enclosures (вложения)&#10;                        if hasattr(entry, 'enclosures') and entry.enclosures:&#10;                            for enclosure in entry.enclosures:&#10;                                if hasattr(enclosure, 'type'):&#10;                                    if enclosure.type.startswith('image/'):&#10;                                        media = {&#10;                                            'type': 'photo',&#10;                                            'url': enclosure.href,&#10;                                            'thumbnail': enclosure.href&#10;                                        }&#10;                                        break&#10;                                    elif enclosure.type.startswith('video/'):&#10;                                        media = {&#10;                                            'type': 'video',&#10;                                            'url': enclosure.href,&#10;                                            'thumbnail': None&#10;                                        }&#10;                                        break&#10;&#10;                        # Проверяем media:content (альтернативный способ)&#10;                        if not media and hasattr(entry, 'media_content') and entry.media_content:&#10;                            for media_item in entry.media_content:&#10;                                if media_item.get('type', '').startswith('image/'):&#10;                                    media = {&#10;                                        'type': 'photo',&#10;                                        'url': media_item.get('url', ''),&#10;                                        'thumbnail': media_item.get('url', '')&#10;                                    }&#10;                                    break&#10;&#10;                        # Очищаем HTML теги из описания&#10;                        import re&#10;                        clean_description = re.sub(r'&lt;[^&gt;]+&gt;', '', description)&#10;                        clean_description = clean_description.strip()[:300] + &quot;...&quot; if len(clean_description) &gt; 300 else clean_description.strip()&#10;&#10;                        article = {&#10;                            'id': hashlib.md5(f&quot;{url}_{title}&quot;.encode()).hexdigest(),&#10;                            'title': title,&#10;                            'text': clean_description,&#10;                            'link': link,&#10;                            'date': date,&#10;                            'source': name,&#10;                            'category': category,&#10;                            'media': media&#10;                        }&#10;&#10;                        articles.append(article)&#10;&#10;                    return articles&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching RSS from {url}: {e}&quot;)&#10;            return []&#10;&#10;    async def save_to_database(self, posts: List[Dict[str, Any]]):&#10;        &quot;&quot;&quot;Сохранение новостей в базу данных&quot;&quot;&quot;&#10;        try:&#10;            # Импортируем здесь, чтобы избежать циркулярного импорта&#10;            import server.main as main_module&#10;            from server.db import NewsItem&#10;&#10;            if main_module.SessionLocal is None:&#10;                logger.error(&quot;Database not initialized&quot;)&#10;                return&#10;&#10;            db = main_module.SessionLocal()&#10;&#10;            try:&#10;                news_items = []&#10;                for post in posts:&#10;                    # Получаем или создаём источник&#10;                    from server.services.news_service import get_or_create_source&#10;                    source = get_or_create_source(db, post.get('source', 'unknown'))&#10;                    # Проверяем, существует ли уже такая новость&#10;                    existing = db.query(NewsItem).filter(&#10;                        NewsItem.title == post['title']&#10;                    ).first()&#10;&#10;                    if existing:&#10;                        continue  # Пропускаем дубликаты&#10;&#10;                    # Извлекаем медиа данные&#10;                    image_url = None&#10;                    video_url = None&#10;&#10;                    if post.get('media'):&#10;                        if post['media']['type'] == 'photo':&#10;                            image_url = post['media']['url']&#10;                        elif post['media']['type'] == 'video':&#10;                            video_url = post['media']['url']&#10;                            if not image_url and post['media'].get('thumbnail'):&#10;                                image_url = post['media']['thumbnail']&#10;&#10;                    # Оценка времени чтения (200 слов в минуту)&#10;                    word_count = len(post['text'].split()) if post.get('text') else 0&#10;                    reading_time = max(1, word_count // 200)&#10;&#10;                    news_item = NewsItem(&#10;                        source_id=source.id,  # &lt;-- добавлено&#10;                        title=post['title'],&#10;                        content=post['text'],&#10;                        link=post['link'],&#10;                        publish_date=datetime.fromisoformat(post['date'].replace('Z', '+00:00')),&#10;                        category=post['category'],&#10;                        image_url=image_url,&#10;                        video_url=video_url,&#10;                        reading_time=reading_time,&#10;                        views_count=0,&#10;                        author=post.get('source'),&#10;                        subtitle=None&#10;                    )&#10;&#10;                    news_items.append(news_item)&#10;&#10;                if news_items:&#10;                    db.bulk_save_objects(news_items)&#10;                    db.commit()&#10;                    logger.info(f&quot;Saved {len(news_items)} new items to database&quot;)&#10;                else:&#10;                    logger.info(&quot;No new items to save&quot;)&#10;&#10;            finally:&#10;                db.close()&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при загрузке каналов: {e}&quot;)&#10;            if 'db' in locals():&#10;                db.rollback()&#10;                db.close()&#10;" />
              <option name="updatedContent" value="import aiohttp&#10;import asyncio&#10;import feedparser&#10;from typing import List, Dict, Any, Optional&#10;import json&#10;from datetime import datetime, timedelta&#10;import logging&#10;import re&#10;import hashlib&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class TelegramNewsService:&#10;    &quot;&quot;&quot;Сервис для получения новостей из Telegram каналов и RSS источников&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Telegram каналы согласно ТЗ - ключевые источники по темам подарков, NFT и крипто&#10;        self.channels = [&#10;            # Каналы о подарках и бонусах&#10;            {'username': 'gift_newstg', 'name': 'Gift News TG', 'category': 'gifts'},&#10;            {'username': 'giftsutya', 'name': 'Gift Sutya', 'category': 'gifts'},&#10;            {'username': 'diruil_gifts', 'name': 'Diruil Gifts', 'category': 'gifts'},&#10;            {'username': 'giftnews', 'name': 'Gift News', 'category': 'gifts'},&#10;            {'username': 'BunnyStarsShop', 'name': 'Bunny Stars Shop', 'category': 'gifts'},&#10;            {'username': 'nft_podarki', 'name': 'NFT Подарки', 'category': 'gifts'},&#10;&#10;            # Технологии и инновации&#10;            {'username': 'westik', 'name': 'Westik', 'category': 'tech'},&#10;&#10;            # Сообщества и чаты&#10;            {'username': 'OHUENKOchat', 'name': 'OHUENKO Chat', 'category': 'community'},&#10;            {'username': 'community', 'name': 'Community', 'category': 'community'},&#10;            {'username': 'groza', 'name': 'Groza', 'category': 'community'},&#10;&#10;            # Криптовалюты и блокчейн&#10;            {'username': 'omicron', 'name': 'Omicron', 'category': 'crypto'},&#10;            {'username': 'tontopic_1', 'name': 'TON Topic', 'category': 'crypto'},&#10;            {'username': 'procryptodoping', 'name': 'Pro Crypto Doping', 'category': 'crypto'},&#10;&#10;            # NFT и цифровое искусство&#10;            {'username': 'nextgen_NFT', 'name': 'NextGen NFT', 'category': 'nft'},&#10;            {'username': 'snoopdogg', 'name': 'Snoop Dogg', 'category': 'nft'}&#10;        ]&#10;&#10;        # RSS источники согласно ТЗ - до 5 проверенных лент&#10;        self.rss_sources = [&#10;            {'url': 'https://vc.ru/rss', 'name': 'VC.ru', 'category': 'tech'},&#10;            {'url': 'https://forklog.com/feed/', 'name': 'ForkLog', 'category': 'crypto'},&#10;            {'url': 'https://www.coindesk.com/arc/outboundfeeds/rss/', 'name': 'CoinDesk', 'category': 'crypto'},&#10;            {'url': 'https://cointelegraph.com/rss', 'name': 'Cointelegraph', 'category': 'crypto'},&#10;            {'url': 'https://habr.com/ru/rss/articles/', 'name': 'Habr NFT', 'category': 'nft'}&#10;        ]&#10;&#10;        self.cache = {}&#10;        self.cache_ttl = timedelta(minutes=30)  # Кэш на 30 минут согласно ТЗ&#10;&#10;        # Ключевые слова для категоризации согласно ТЗ&#10;        self.keywords = {&#10;            'gifts': [&#10;                'подарок', 'подарки', 'бесплатно', 'халява', 'промокод', 'скидка',&#10;                'акция', 'розыгрыш', 'бонус', 'даром', 'гифт', 'gift', 'freebie',&#10;                'раздача', 'конкурс', 'приз', 'награда', 'cashback', 'кэшбек'&#10;            ],&#10;            'nft': [&#10;                'nft', 'нфт', 'токен', 'коллекция', 'мета', 'opensea', 'digital art',&#10;                'коллекционный', 'цифровое искусство', 'метавселенная', 'avatar',&#10;                'аватар', 'pfp', 'mint', 'минт', 'drop', 'дроп', 'rare', 'раритет'&#10;            ],&#10;            'crypto': [&#10;                'криптовалюта', 'биткоин', 'bitcoin', 'ethereum', 'блокчейн', 'деф',&#10;                'defi', 'торги', 'курс', 'btc', 'eth', 'usdt', 'binance', 'трейдинг',&#10;                'стейкинг', 'майнинг', 'altcoin', 'альткоин', 'pump', 'dump', 'hodl'&#10;            ],&#10;            'tech': [&#10;                'технологии', 'it', 'ит', 'программирование', 'разработка', 'стартап',&#10;                'инновации', 'ai', 'ии', 'machine learning', 'блокчейн', 'веб3',&#10;                'app', 'приложение', 'software', 'hardware', 'gadget', 'гаджет'&#10;            ],&#10;            'community': [&#10;                'сообщество', 'чат', 'общение', 'форум', 'дискуссия', 'мнение',&#10;                'обсуждение', 'новости', 'анонс', 'встреча', 'event', 'мероприятие'&#10;            ]&#10;        }&#10;&#10;    def categorize_content(self, title: str, description: str = &quot;&quot;) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Автоматическая категоризация контента по ключевым словам согласно ТЗ&#10;        Приоритет: gifts &gt; crypto &gt; nft &gt; tech &gt; community&#10;        &quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        # Подсчитываем совпадения для каждой категории&#10;        category_scores = {}&#10;        for category, keywords in self.keywords.items():&#10;            score = sum(1 for keyword in keywords if keyword in content)&#10;            if score &gt; 0:&#10;                category_scores[category] = score&#10;&#10;        if not category_scores:&#10;            return 'general'&#10;&#10;        # Возвращаем категорию с наибольшим количеством совпадений&#10;        # При равенстве очков используем приоритет&#10;        priority = ['gifts', 'crypto', 'nft', 'tech', 'community']&#10;&#10;        max_score = max(category_scores.values())&#10;        best_categories = [cat for cat, score in category_scores.items() if score == max_score]&#10;&#10;        for priority_cat in priority:&#10;            if priority_cat in best_categories:&#10;                return priority_cat&#10;&#10;        return list(category_scores.keys())[0]  # Fallback&#10;&#10;    async def fetch_telegram_channel(self, channel_username: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получение новостей из Telegram канала через веб-скрапинг&#10;        Согласно ТЗ - интеграция с Telegram каналами для получения актуальных новостей&#10;        &quot;&quot;&quot;&#10;        try:&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == channel_username), None)&#10;            if not channel_data:&#10;                logger.warning(f&quot;Channel {channel_username} not found in configured channels&quot;)&#10;                return []&#10;&#10;            # Используем публичный API Telegram для получения постов&#10;            url = f&quot;https://t.me/s/{channel_username}&quot;&#10;&#10;            async with aiohttp.ClientSession() as session:&#10;                try:&#10;                    async with session.get(url, timeout=10) as response:&#10;                        if response.status == 200:&#10;                            html_content = await response.text()&#10;                            return self._parse_telegram_html(html_content, channel_data)&#10;                        else:&#10;                            logger.warning(f&quot;Failed to fetch {url}, status: {response.status}&quot;)&#10;                            return self._generate_mock_posts(channel_data)&#10;                except aiohttp.ClientTimeout:&#10;                    logger.warning(f&quot;Timeout fetching {url}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;                except Exception as e:&#10;                    logger.warning(f&quot;Error fetching {url}: {e}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in fetch_telegram_channel for {channel_username}: {e}&quot;)&#10;            return []&#10;&#10;    def _parse_telegram_html(self, html_content: str, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Парсинг HTML содержимого Telegram канала с поддержкой медиа&quot;&quot;&quot;&#10;        import re&#10;        from html import unescape&#10;&#10;        posts = []&#10;&#10;        # Простой парсер для получения постов из HTML&#10;        # В реальном проекте лучше использовать BeautifulSoup&#10;        post_pattern = r'&lt;div class=&quot;tgme_widget_message.*?&lt;/div&gt;\s*&lt;/div&gt;\s*&lt;/div&gt;'&#10;        text_pattern = r'&lt;div class=&quot;tgme_widget_message_text.*?&quot;.*?&gt;(.*?)&lt;/div&gt;'&#10;        date_pattern = r'&lt;time.*?datetime=&quot;([^&quot;]+)&quot;'&#10;&#10;        # Паттерны для медиа контента&#10;        photo_pattern = r'&lt;a.*?class=&quot;tgme_widget_message_photo_wrap.*?style=&quot;background-image:url\(&amp;quot;([^&amp;]+)&amp;quot;\)&quot;'&#10;        video_pattern = r'&lt;video.*?src=&quot;([^&quot;]+)&quot;.*?poster=&quot;([^&quot;]*)&quot;.*?&gt;'&#10;        video_thumb_pattern = r'&lt;video.*?poster=&quot;([^&quot;]+)&quot;.*?&gt;'&#10;&#10;        post_matches = re.findall(post_pattern, html_content, re.DOTALL)&#10;&#10;        for i, post_html in enumerate(post_matches[:10]):  # Берем только первые 10 постов&#10;            # Извлекаем текст поста&#10;            text_match = re.search(text_pattern, post_html, re.DOTALL)&#10;            text = &quot;&quot;&#10;            if text_match:&#10;                text = unescape(re.sub(r'&lt;[^&gt;]+&gt;', '', text_match.group(1)))&#10;                text = text.strip()[:300] + &quot;...&quot; if len(text) &gt; 300 else text.strip()&#10;&#10;            # Извлекаем дату&#10;            date_match = re.search(date_pattern, post_html)&#10;            date = datetime.now().isoformat()&#10;            if date_match:&#10;                try:&#10;                    date = datetime.fromisoformat(date_match.group(1).replace('Z', '+00:00')).isoformat()&#10;                except:&#10;                    pass&#10;&#10;            # Извлекаем медиа контент&#10;            media = None&#10;&#10;            # Проверяем на фото&#10;            photo_match = re.search(photo_pattern, post_html)&#10;            if photo_match:&#10;                photo_url = photo_match.group(1).replace('&amp;amp;', '&amp;')&#10;                media = {&#10;                    'type': 'photo',&#10;                    'url': photo_url,&#10;                    'thumbnail': photo_url,  # Для фото thumbnail = основное изображение&#10;                    'width': None,&#10;                    'height': None&#10;                }&#10;&#10;            # Проверяем на видео&#10;            video_match = re.search(video_pattern, post_html)&#10;            if video_match:&#10;                video_url = video_match.group(1)&#10;                thumbnail_url = video_match.group(2) if len(video_match.groups()) &gt; 1 else None&#10;                media = {&#10;                    'type': 'video',&#10;                    'url': video_url,&#10;                    'thumbnail': thumbnail_url,&#10;                    'width': None,&#10;                    'height': None&#10;                }&#10;            elif not media:  # Если не нашли полное видео, ищем только thumbnail&#10;                video_thumb_match = re.search(video_thumb_pattern, post_html)&#10;                if video_thumb_match:&#10;                    media = {&#10;                        'type': 'video',&#10;                        'url': None,  # URL видео не найден&#10;                        'thumbnail': video_thumb_match.group(1),&#10;                        'width': None,&#10;                        'height': None&#10;                    }&#10;&#10;            if text:  # Только если удалось извлечь текст&#10;                # Генерируем заголовок из первых слов&#10;                title = text.split('.')[0][:100] if text else f&quot;Пост от {channel_data['name']}&quot;&#10;&#10;                post = {&#10;                    'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text[:50]}&quot;.encode()).hexdigest(),&#10;                    'title': title,&#10;                    'text': text,&#10;                    'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                    'date': date,&#10;                    'source': channel_data['name'],&#10;                    'category': channel_data['category'],&#10;                    'channel': channel_data['username'],&#10;                    'media': media  # Добавляем медиа данные&#10;                }&#10;&#10;                posts.append(post)&#10;&#10;        if not posts:  # Если парсинг не удался, используем мок данные&#10;            return self._generate_mock_posts(channel_data)&#10;&#10;        return posts&#10;&#10;    def _generate_mock_posts(self, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Генерация мок данных для канала согласно ТЗ&quot;&quot;&quot;&#10;        posts = []&#10;        base_time = datetime.now()&#10;&#10;        # Контент в зависимости от категории канала&#10;        content_templates = {&#10;            'gifts': [&#10;                &quot; Новые бесплатные подарки! Успейте получить эксклюзивные бонусы&quot;,&#10;                &quot; Промокоды на скидки до 70%! Ограниченное предложение&quot;,&#10;                &quot; Розыгрыш ценных призов среди подписчиков канала&quot;,&#10;                &quot;️ Лучшие предложения дня - не пропустите!&quot;&#10;            ],&#10;            'crypto': [&#10;                &quot; Анализ рынка: Bitcoin показывает рост на 5%&quot;,&#10;                &quot; Новые возможности DeFi инвестиций - обзор проектов&quot;,&#10;                &quot; Перспективные альткоины для долгосрочных инвестиций&quot;,&#10;                &quot;⚡ Срочные новости: крупные движения на криптовалютном рынке&quot;&#10;            ],&#10;            'nft': [&#10;                &quot;️ Новая коллекция NFT от известного художника уже в продаже&quot;,&#10;                &quot; Раритетные токены на аукционе - последний шанс приобрести&quot;,&#10;                &quot; Обзор лучших NFT художников недели&quot;,&#10;                &quot; Статистика NFT рынка: рост объемов торгов на 15%&quot;&#10;            ],&#10;            'tech': [&#10;                &quot; Революционные технологии 2025 года - что нас ждет&quot;,&#10;                &quot; Обзор новейших гаджетов от мировых производителей&quot;,&#10;                &quot; Стартапы в сфере ИИ привлекли рекордные инвестиции&quot;,&#10;                &quot; ТОП мобильных приложений для повышения продуктивности&quot;&#10;            ],&#10;            'community': [&#10;                &quot; Обсуждение актуальных тем в нашем сообществе&quot;,&#10;                &quot; Важные новости и обновления для участников&quot;,&#10;                &quot; Анонс предстоящих мероприятий и встреч&quot;,&#10;                &quot; Полезные советы и рекомендации от экспертов&quot;&#10;            ]&#10;        }&#10;&#10;        templates = content_templates.get(channel_data['category'], content_templates['community'])&#10;&#10;        for i in range(5):  # Генерируем 5 постов&#10;            post_time = base_time - timedelta(hours=i * 4 + hash(channel_data['username']) % 12)&#10;&#10;            text = templates[i % len(templates)]&#10;            title = text.split('.')[0][:80] + (&quot;...&quot; if len(text.split('.')[0]) &gt; 80 else &quot;&quot;)&#10;&#10;            posts.append({&#10;                'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text}&quot;.encode()).hexdigest(),&#10;                'title': title,&#10;                'text': text,&#10;                'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                'date': post_time.isoformat(),&#10;                'source': channel_data['name'],&#10;                'category': channel_data['category'],&#10;                'channel': channel_data['username']&#10;            })&#10;&#10;        return posts&#10;        &quot;&quot;&quot;Автоматическая категоризация контента по ключевым словам&quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        for category, keywords in self.keywords.items():&#10;            if any(keyword in content for keyword in keywords):&#10;                return category&#10;&#10;        return 'general'&#10;&#10;    async def fetch_rss_feed(self, source: Dict[str, str]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получение новостей из RSS источника&quot;&quot;&quot;&#10;        try:&#10;            # Используем feedparser для парсинга RSS&#10;            feed = feedparser.parse(source['url'])&#10;&#10;            if not feed.entries:&#10;                logger.warning(f&quot;No entries found in RSS feed: {source['url']}&quot;)&#10;                return []&#10;&#10;            articles = []&#10;            for entry in feed.entries[:10]:  # Берем только последние 10 новостей&#10;                # Получаем описание из различных полей&#10;                description = &quot;&quot;&#10;                if hasattr(entry, 'summary'):&#10;                    description = entry.summary&#10;                elif hasattr(entry, 'description'):&#10;                    description = entry.description&#10;                elif hasattr(entry, 'content'):&#10;                    description = entry.content[0].value if entry.content else &quot;&quot;&#10;&#10;                # Очищаем HTML теги&#10;                clean_description = re.sub(r'&lt;[^&gt;]+&gt;', '', description)&#10;                clean_description = clean_description[:200] + &quot;...&quot; if len(&#10;                    clean_description) &gt; 200 else clean_description&#10;&#10;                # Получаем дату публикации&#10;                pub_date = datetime.now()&#10;                if hasattr(entry, 'published_parsed') and entry.published_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.published_parsed))&#10;                elif hasattr(entry, 'updated_parsed') and entry.updated_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.updated_parsed))&#10;&#10;                # Автоматическая категоризация&#10;                auto_category = self.categorize_content(entry.title, clean_description)&#10;                final_category = source.get('category', auto_category)&#10;&#10;                # Извлекаем медиа контент&#10;                media = None&#10;&#10;                # Проверяем enclosures (вложения)&#10;                if hasattr(entry, 'enclosures') and entry.enclosures:&#10;                    for enclosure in entry.enclosures:&#10;                        if hasattr(enclosure, 'type'):&#10;                            if enclosure.type.startswith('image/'):&#10;                                media = {&#10;                                    'type': 'photo',&#10;                                    'url': enclosure.href,&#10;                                    'thumbnail': enclosure.href&#10;                                }&#10;                                break&#10;                            elif enclosure.type.startswith('video/'):&#10;                                media = {&#10;                                    'type': 'video',&#10;                                    'url': enclosure.href,&#10;                                    'thumbnail': None&#10;                                }&#10;                                break&#10;&#10;                # Проверяем media:content (альтернативный способ)&#10;                if not media and hasattr(entry, 'media_content') and entry.media_content:&#10;                    for media_item in entry.media_content:&#10;                        if media_item.get('type', '').startswith('image/'):&#10;                            media = {&#10;                                'type': 'photo',&#10;                                'url': media_item.get('url', ''),&#10;                                'thumbnail': media_item.get('url', '')&#10;                            }&#10;                            break&#10;&#10;                # Формируем HTML контент&#10;                content_html = clean_description&#10;                if media:&#10;                    if media.get('type') == 'photo' and media.get('url'):&#10;                        content_html += f'&lt;img src=&quot;{media[&quot;url&quot;]}&quot; style=&quot;max-width:100%&quot;/&gt;'&#10;                    elif media.get('type') == 'video' and media.get('url'):&#10;                        thumbnail = media.get('thumbnail', '')&#10;                        content_html += f'&lt;video controls poster=&quot;{thumbnail}&quot; style=&quot;max-width:100%&quot;&gt;'&#10;                        content_html += f'&lt;source src=&quot;{media[&quot;url&quot;]}&quot; type=&quot;video/mp4&quot;&gt;'&#10;                        content_html += '&lt;/video&gt;'&#10;&#10;                article = {&#10;                    'id': hashlib.md5((entry.link + entry.title).encode()).hexdigest(),&#10;                    'title': entry.title,&#10;                    'text': clean_description,  # Plain text&#10;                    'content_html': content_html,  # HTML с медиа&#10;                    'link': entry.link,&#10;                    'date': pub_date.isoformat(),&#10;                    'source': source['name'],&#10;                    'category': final_category,&#10;                    'channel': 'rss_' + source['name'].lower().replace(' ', '_'),&#10;                    'media': [media] if media else None&#10;                }&#10;&#10;                articles.append(article)&#10;&#10;            return articles&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching RSS feed {source['url']}: {e}&quot;)&#10;            return []&#10;        &quot;&quot;&quot;Получить информацию о канале через Telegram API&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока возвращаем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return None&#10;&#10;            return {&#10;                'username': username,&#10;                'title': channel_data['name'],&#10;                'description': f&quot;Канал {channel_data['name']} - {channel_data['category']}&quot;,&#10;                'subscribers_count': 1000 + hash(username) % 50000,  # Мок количества подписчиков&#10;                'category': channel_data['category']&#10;            }&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channel info for {username}: {e}&quot;)&#10;            return None&#10;&#10;    async def get_channel_posts(self, username: str, limit: int = 10) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить последние посты из канала&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока генерируем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return []&#10;&#10;            posts = []&#10;            base_time = datetime.now()&#10;&#10;            for i in range(limit):&#10;                post_time = base_time - timedelta(hours=i * 2 + hash(username + str(i)) % 24)&#10;&#10;                # Генерируем контент на основе категории&#10;                if channel_data['category'] == 'gifts':&#10;                    titles = [&#10;                        f&quot; Новые бесплатные подарки в {channel_data['name']}!&quot;,&#10;                        f&quot; Эксклюзивные промокоды и скидки&quot;,&#10;                        f&quot; Розыгрыш призов для подписчиков&quot;,&#10;                        f&quot;️ Лучшие предложения дня&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'crypto':&#10;                    titles = [&#10;                        f&quot; Анализ рынка криптовалют&quot;,&#10;                        f&quot; Новые возможности для инвестиций&quot;,&#10;                        f&quot; Обзор перспективных проектов&quot;,&#10;                        f&quot;⚡ Быстрые новости из мира крипто&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'nft':&#10;                    titles = [&#10;                        f&quot;️ Новые NFT коллекции&quot;,&#10;                        f&quot; Раритетные токены на аукционе&quot;,&#10;                        f&quot; Обзор NFT художников&quot;,&#10;                        f&quot; Статистика NFT рынка&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'tech':&#10;                    titles = [&#10;                        f&quot; Новости технологий&quot;,&#10;                        f&quot; Обзор гаджетов&quot;,&#10;                        f&quot; Инновации в IT&quot;,&#10;                        f&quot; Мобильные приложения&quot;&#10;                    ]&#10;                else:&#10;                    titles = [&#10;                        f&quot; Новости от {channel_data['name']}&quot;,&#10;                        f&quot;ℹ️ Важные обновления&quot;,&#10;                        f&quot; Полезная информация&quot;,&#10;                        f&quot; Горячие темы&quot;&#10;                    ]&#10;&#10;                title = titles[i % len(titles)]&#10;&#10;                posts.append({&#10;                    'id': f&quot;{username}_{i}&quot;,&#10;                    'title': title,&#10;                    'text': f&quot;Интересный контент от канала {channel_data['name']}. Подписывайтесь для получения актуальных новостей!&quot;,&#10;                    'date': post_time.isoformat(),&#10;                    'views': 100 + hash(username + str(i)) % 5000,&#10;                    'link': f&quot;https://t.me/{username}&quot;,&#10;                    'channel': username,&#10;                    'category': channel_data['category']&#10;                })&#10;&#10;            return posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting posts for {username}: {e}&quot;)&#10;            return []&#10;&#10;    async def get_all_news(self, category: str = 'all', limit: int = 50) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получить новости из всех источников согласно ТЗ:&#10;        - Telegram каналы (основные источники)&#10;        - RSS ленты (дополнительные источники)&#10;        - Автоматическая категоризация и дедупликация&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Проверяем кэш&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, cached_time = self.cache[cache_key]&#10;                if datetime.now() - cached_time &lt; self.cache_ttl:&#10;                    logger.info(f&quot;Returning cached news for {category}, {len(cached_data)} items&quot;)&#10;                    return cached_data&#10;&#10;            all_posts = []&#10;&#10;            # 1. Получаем данные из Telegram каналов (приоритетный источник согласно ТЗ)&#10;            telegram_channels = self.channels&#10;            if category != 'all':&#10;                telegram_channels = [ch for ch in self.channels if ch['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(telegram_channels)} Telegram channels&quot;)&#10;&#10;            # Получаем посты из Telegram каналов&#10;            telegram_tasks = []&#10;            for channel in telegram_channels:&#10;                telegram_tasks.append(self.fetch_telegram_channel(channel['username']))&#10;&#10;            telegram_results = await asyncio.gather(*telegram_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(telegram_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} posts from {telegram_channels[i]['username']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching posts from {telegram_channels[i]['username']}: {result}&quot;)&#10;&#10;            # 2. Получаем данные из RSS источников (дополнительный источник)&#10;            rss_sources = self.rss_sources&#10;            if category != 'all':&#10;                rss_sources = [src for src in self.rss_sources if src['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(rss_sources)} RSS sources&quot;)&#10;&#10;            # Получаем статьи из RSS&#10;            rss_tasks = []&#10;            for source in rss_sources:&#10;                rss_tasks.append(self.fetch_rss_feed(source))&#10;&#10;            rss_results = await asyncio.gather(*rss_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(rss_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} articles from {rss_sources[i]['name']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching RSS from {rss_sources[i]['url']}: {result}&quot;)&#10;&#10;            # 3. Обработка и дедупликация согласно ТЗ&#10;            # Удаляем дубликаты по заголовку и ссылке&#10;            seen = set()&#10;            unique_posts = []&#10;            for post in all_posts:&#10;                # Создаем ключ для дедупликации&#10;                title_clean = re.sub(r'[^\w\s]', '', post['title'].lower()).strip()&#10;                key = (title_clean, post.get('link', ''))&#10;                if key not in seen:&#10;                    seen.add(key)&#10;                    unique_posts.append(post)&#10;&#10;            logger.info(f&quot;After deduplication: {len(unique_posts)} unique posts from {len(all_posts)} total&quot;)&#10;&#10;            # 4. Сортировка по дате (новые сначала)&#10;            try:&#10;                unique_posts.sort(&#10;                    key=lambda x: datetime.fromisoformat(x['date'].replace('Z', '+00:00')),&#10;                    reverse=True&#10;                )&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error sorting by date: {e}, using original order&quot;)&#10;&#10;            # 5. Ограничиваем количество согласно ТЗ&#10;            final_posts = unique_posts[:limit]&#10;&#10;            # 6. Сохраняем в кэш на 30 минут согласно ТЗ&#10;            self.cache[cache_key] = (final_posts, datetime.now())&#10;&#10;            logger.info(f&quot;Returning {len(final_posts)} news items for category '{category}'&quot;)&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in get_all_news: {e}&quot;)&#10;            # В случае ошибки возвращаем данные из кэша, если есть&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, _ = self.cache[cache_key]&#10;                logger.info(&quot;Returning stale cached data due to error&quot;)&#10;                return cached_data&#10;            return []&#10;&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting all news: {e}&quot;)&#10;            return []&#10;&#10;    async def get_channels_info(self) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить информацию о всех каналах&quot;&quot;&quot;&#10;        try:&#10;            tasks = []&#10;            for channel in self.channels:&#10;                tasks.append(self.get_channel_info(channel['username']))&#10;&#10;            results = await asyncio.gather(*tasks, return_exceptions=True)&#10;&#10;            channels_info = []&#10;            for result in results:&#10;                if isinstance(result, dict):&#10;                    channels_info.append(result)&#10;&#10;            return channels_info&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channels info: {e}&quot;)&#10;            return []&#10;&#10;    async def update_news_async(self):&#10;        &quot;&quot;&quot;&#10;        Асинхронное обновление новостей из всех источников&#10;        Метод для периодического обновления в main.py&#10;        &quot;&quot;&quot;&#10;        try:&#10;            logger.info(f&quot;Fetching from {len(self.channels)} Telegram channels&quot;)&#10;&#10;            # Получаем новости из Telegram каналов&#10;            all_posts = []&#10;            for channel in self.channels:&#10;                try:&#10;                    posts = await self.fetch_telegram_channel(channel['username'])&#10;                    logger.info(f&quot;Got {len(posts)} posts from {channel['username']}&quot;)&#10;                    all_posts.extend(posts)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Error fetching from channel {channel['username']}: {e}&quot;)&#10;                    continue&#10;&#10;            # Получаем новости из RSS источников&#10;            logger.info(f&quot;Fetching from {len(self.rss_sources)} RSS sources&quot;)&#10;            for source in self.rss_sources:&#10;                try:&#10;                    articles = await self.fetch_rss_source(source['url'], source['name'], source['category'])&#10;                    logger.info(f&quot;Got {len(articles)} articles from {source['name']}&quot;)&#10;                    all_posts.extend(articles)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Error fetching from RSS {source['name']}: {e}&quot;)&#10;                    continue&#10;&#10;            # Дедуплицируем по заголовкам&#10;            unique_posts = []&#10;            seen_titles = set()&#10;&#10;            for post in all_posts:&#10;                title_hash = hashlib.md5(post['title'].encode()).hexdigest()&#10;                if title_hash not in seen_titles:&#10;                    seen_titles.add(title_hash)&#10;                    unique_posts.append(post)&#10;&#10;            logger.info(f&quot;After deduplication: {len(unique_posts)} unique posts from {len(all_posts)} total&quot;)&#10;&#10;            # Сортируем по дате (новые сначала)&#10;            try:&#10;                unique_posts.sort(key=lambda x: x['date'], reverse=True)&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error sorting by date: {e}, using original order&quot;)&#10;&#10;            # Сохраняем в базу данных&#10;            await self.save_to_database(unique_posts[:50])  # Сохраняем только 50 самых свежих&#10;&#10;            logger.info(f&quot;Successfully updated {len(unique_posts[:50])} news items&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in update_news_async: {e}&quot;)&#10;            raise&#10;&#10;    async def fetch_rss_source(self, url: str, name: str, category: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получение новостей из RSS источника&quot;&quot;&quot;&#10;        try:&#10;            async with aiohttp.ClientSession() as session:&#10;                async with session.get(url, timeout=10) as response:&#10;                    if response.status != 200:&#10;                        logger.warning(f&quot;Failed to fetch RSS {url}, status: {response.status}&quot;)&#10;                        return []&#10;&#10;                    content = await response.text()&#10;                    feed = feedparser.parse(content)&#10;&#10;                    if not feed.entries:&#10;                        logger.warning(f&quot;No entries found in RSS feed: {url}&quot;)&#10;                        return []&#10;&#10;                    articles = []&#10;                    for entry in feed.entries[:10]:  # Берем только 10 последних статей&#10;                        # Извлекаем основную информацию&#10;                        title = entry.get('title', 'Без заголовка')&#10;                        description = entry.get('description', '') or entry.get('summary', '')&#10;                        link = entry.get('link', '')&#10;&#10;                        # Парсим дату&#10;                        date = datetime.now().isoformat()&#10;                        if hasattr(entry, 'published_parsed') and entry.published_parsed:&#10;                            try:&#10;                                import time&#10;                                date = datetime.fromtimestamp(time.mktime(entry.published_parsed)).isoformat()&#10;                            except:&#10;                                pass&#10;&#10;                        # Извлекаем медиа контент&#10;                        media = None&#10;&#10;                        # Проверяем enclosures (вложения)&#10;                        if hasattr(entry, 'enclosures') and entry.enclosures:&#10;                            for enclosure in entry.enclosures:&#10;                                if hasattr(enclosure, 'type'):&#10;                                    if enclosure.type.startswith('image/'):&#10;                                        media = {&#10;                                            'type': 'photo',&#10;                                            'url': enclosure.href,&#10;                                            'thumbnail': enclosure.href&#10;                                        }&#10;                                        break&#10;                                    elif enclosure.type.startswith('video/'):&#10;                                        media = {&#10;                                            'type': 'video',&#10;                                            'url': enclosure.href,&#10;                                            'thumbnail': None&#10;                                        }&#10;                                        break&#10;&#10;                        # Проверяем media:content (альтернативный способ)&#10;                        if not media and hasattr(entry, 'media_content') and entry.media_content:&#10;                            for media_item in entry.media_content:&#10;                                if media_item.get('type', '').startswith('image/'):&#10;                                    media = {&#10;                                        'type': 'photo',&#10;                                        'url': media_item.get('url', ''),&#10;                                        'thumbnail': media_item.get('url', '')&#10;                                    }&#10;                                    break&#10;&#10;                        # Очищаем HTML теги из описания&#10;                        import re&#10;                        clean_description = re.sub(r'&lt;[^&gt;]+&gt;', '', description)&#10;                        clean_description = clean_description.strip()[:300] + &quot;...&quot; if len(clean_description) &gt; 300 else clean_description.strip()&#10;&#10;                        article = {&#10;                            'id': hashlib.md5(f&quot;{url}_{title}&quot;.encode()).hexdigest(),&#10;                            'title': title,&#10;                            'text': clean_description,&#10;                            'link': link,&#10;                            'date': date,&#10;                            'source': name,&#10;                            'category': category,&#10;                            'media': media&#10;                        }&#10;&#10;                        articles.append(article)&#10;&#10;                    return articles&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching RSS from {url}: {e}&quot;)&#10;            return []&#10;&#10;    async def save_to_database(self, posts: List[Dict[str, Any]]):&#10;        &quot;&quot;&quot;Сохранение новостей в базу данных&quot;&quot;&quot;&#10;        try:&#10;            # Импортируем здесь, чтобы избежать циркулярного импорта&#10;            import server.main as main_module&#10;            from server.db import NewsItem&#10;&#10;            if main_module.SessionLocal is None:&#10;                logger.error(&quot;Database not initialized&quot;)&#10;                return&#10;&#10;            db = main_module.SessionLocal()&#10;&#10;            try:&#10;                news_items = []&#10;                for post in posts:&#10;                    # Получаем или создаём источник&#10;                    from server.services.news_service import get_or_create_source&#10;                    # Определяем тип источника и url&#10;                    source_type = 'telegram' if post.get('channel') and not post.get('link', '').startswith('http') else 'rss'&#10;                    source_url = post.get('link') or ''&#10;                    category = post.get('category') or 'general'&#10;                    source = get_or_create_source(db, post.get('source', 'unknown'), url=source_url, source_type=source_type, category=category)&#10;                    # Проверяем, существует ли уже такая новость&#10;                    existing = db.query(NewsItem).filter(&#10;                        NewsItem.title == post['title']&#10;                    ).first()&#10;&#10;                    if existing:&#10;                        continue  # Пропускаем дубликаты&#10;&#10;                    # Извлекаем медиа данные&#10;                    image_url = None&#10;                    video_url = None&#10;&#10;                    if post.get('media'):&#10;                        if post['media']['type'] == 'photo':&#10;                            image_url = post['media']['url']&#10;                        elif post['media']['type'] == 'video':&#10;                            video_url = post['media']['url']&#10;                            if not image_url and post['media'].get('thumbnail'):&#10;                                image_url = post['media']['thumbnail']&#10;&#10;                    # Оценка времени чтения (200 слов в минуту)&#10;                    word_count = len(post['text'].split()) if post.get('text') else 0&#10;                    reading_time = max(1, word_count // 200)&#10;&#10;                    news_item = NewsItem(&#10;                        source_id=source.id,&#10;                        title=post['title'],&#10;                        content=post['text'],&#10;                        link=post['link'],&#10;                        publish_date=datetime.fromisoformat(post['date'].replace('Z', '+00:00')),&#10;                        category=category,&#10;                        image_url=image_url,&#10;                        video_url=video_url,&#10;                        reading_time=reading_time,&#10;                        views_count=0,&#10;                        author=post.get('source'),&#10;                        subtitle=None&#10;                    )&#10;&#10;                    news_items.append(news_item)&#10;&#10;                if news_items:&#10;                    db.bulk_save_objects(news_items)&#10;                    db.commit()&#10;                    logger.info(f&quot;Saved {len(news_items)} new items to database&quot;)&#10;                else:&#10;                    logger.info(&quot;No new items to save&quot;)&#10;&#10;            finally:&#10;                db.close()&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при загрузке каналов: {e}&quot;)&#10;            if 'db' in locals():&#10;                db.rollback()&#10;                db.close()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/services/news_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/services/news_service.py" />
              <option name="originalContent" value="# services/news_service.py&#10;from sqlalchemy.orm import Session&#10;from server.db import NewsSource  # Импортируйте вашу модель NewsSource&#10;&#10;&#10;def get_or_create_source(session: Session, source_name: str) -&gt; NewsSource:&#10;    &quot;&quot;&quot;&#10;    Находит или создаёт источник новостей.&#10;&#10;    Args:&#10;        session: SQLAlchemy сессия&#10;        source_name: Название источника&#10;&#10;    Returns:&#10;        Объект NewsSource (существующий или новый)&#10;    &quot;&quot;&quot;&#10;    # Пытаемся найти существующий источник&#10;    source = session.query(NewsSource).filter_by(name=source_name).first()&#10;&#10;    # Если не нашли - создаём новый&#10;    if not source:&#10;        source = NewsSource(name=source_name)&#10;        session.add(source)&#10;        session.flush()  # Получаем ID без коммита всей транзакции&#10;&#10;    return source" />
              <option name="updatedContent" value="# services/news_service.py&#10;from sqlalchemy.orm import Session&#10;from server.db import NewsSource  # Импортируйте вашу модель NewsSource&#10;&#10;&#10;def get_or_create_source(session: Session, source_name: str, url: str = None, source_type: str = None, category: str = None) -&gt; NewsSource:&#10;    &quot;&quot;&quot;&#10;    Находит или создаёт источник новостей.&#10;&#10;    Args:&#10;        session: SQLAlchemy сессия&#10;        source_name: Название источника&#10;        url: URL источника&#10;        source_type: Тип источника (например, 'telegram', 'rss')&#10;        category: Категория источника&#10;&#10;    Returns:&#10;        Объект NewsSource (существующий или новый)&#10;    &quot;&quot;&quot;&#10;    # Пытаемся найти существующий источник&#10;    source = session.query(NewsSource).filter_by(name=source_name).first()&#10;&#10;    # Если не нашли - создаём новый&#10;    if not source:&#10;        # Заполняем обязательные поля&#10;        source = NewsSource(&#10;            name=source_name,&#10;            url=url or '',&#10;            source_type=source_type or 'telegram',&#10;            category=category,&#10;            is_active=True&#10;        )&#10;        session.add(source)&#10;        session.flush()  # Получаем ID без коммита всей транзакции&#10;&#10;    return source" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>